<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ka1t4v.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0x00 前言为什么使用syscall直接调用内核函数？ 现在很多AV&#x2F;EDR会基于对用户模式的一些API进行hook，从而检测敏感的操作，比如运行线程，申请内存，以及读写内存，所以直接使用syscall，可以绕过此类检测，从而增强免杀能力">
<meta property="og:type" content="article">
<meta property="og:title" content="Syscall学习">
<meta property="og:url" content="https://ka1t4v.github.io/2022/08/01/Syscall_Bypass/index.html">
<meta property="og:site_name" content="Ka1t4v">
<meta property="og:description" content="0x00 前言为什么使用syscall直接调用内核函数？ 现在很多AV&#x2F;EDR会基于对用户模式的一些API进行hook，从而检测敏感的操作，比如运行线程，申请内存，以及读写内存，所以直接使用syscall，可以绕过此类检测，从而增强免杀能力">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220729154941445.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801164846623.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172012539.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172141933.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172425335.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/normal-api-flow.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/crafted-syscall-flow.png">
<meta property="article:published_time" content="2022-08-01T09:46:25.000Z">
<meta property="article:modified_time" content="2022-08-01T10:30:20.963Z">
<meta property="article:author" content="Ka1t4v">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220729154941445.png">

<link rel="canonical" href="https://ka1t4v.github.io/2022/08/01/Syscall_Bypass/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Syscall学习 | Ka1t4v</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ka1t4v</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ka1t4v.github.io/2022/08/01/Syscall_Bypass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/config/avatar.jpg">
      <meta itemprop="name" content="Ka1t4v">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ka1t4v">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Syscall学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-01 17:46:25" itemprop="dateCreated datePublished" datetime="2022-08-01T17:46:25+08:00">2022-08-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>为什么使用syscall直接调用内核函数？</p>
<p>现在很多AV&#x2F;EDR会基于对用户模式的一些API进行hook，从而检测敏感的操作，比如运行线程，申请内存，以及读写内存，所以直接使用syscall，可以绕过此类检测，从而增强免杀能力</p>
<span id="more"></span>

<p>Hook一般放置在kernel32.dll、kernelbase.dl、ntdll.dll之中，在EDR环境中，如果调用的函数被 HOOK，则跳转到EDR的dll之中，该dll一般在进程启动时被加载</p>
<p>相关文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/">https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/</a></p>
<p><a target="_blank" rel="noopener" href="https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/">https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/</a></p>
<p>syscall基本概念：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Windows下有两种处理器访问模式：用户模式（user mode）和内核模式（kernel mode）。用户模式下运行应用程序时，Windows 会为该程序创建一个新进程，提供一个私有虚拟地址空间和一个私有句柄表，因为私有，一个应用程序无法修改另一个应用程序的私有虚拟地址空间的数据；内核模式下，所有运行的代码都共享一个虚拟地址空间， 因此内核中驱动程序可能还会因为写入错误的地址空间导致其他驱动程序甚至系统出现错误</span><br><span class="line"></span><br><span class="line">内核中包含了大部分操作系统的内部数据结构，所以用户模式下的应用程序在访问这些数据结构或调用内部Windows例程以执行特权操作的时候，必须先从用户模式切换到内核模式，这里就涉及到系统调用</span><br><span class="line"></span><br><span class="line">x86 windows 使用 sysenter 实现系统调用</span><br><span class="line">x64 windows 使用 syscall  实现系统调用</span><br></pre></td></tr></table></figure>

<p>就之前的windows dll注入中使用ntdll.dll中的内核函数NtCreateThreadEx创建远线程的注入方法，虽然调用了是比较底层的NtCreateThreadEx函数，但如果对于ntdll.dll进行hook那么这个行为还是会被检测到，实际上NtCreateThreadEx最终还是会执行syscall使用系统调用进入内核层进行操作，所以直接可以绕过调用NtCreateThreadEx从而直接进行syscll实现bypass</p>
<p>Windows自从Vista版本开始，引入了PatchGuard (PG)策略，来保护内核的关键区域不被修改，从而杜绝了之前一些安全厂商做的SSDT表hook，所以检测syscall就变得更加困难，这些内核关键区域包括</p>
<ul>
<li>System Service Descriptor Table (SSDT)</li>
<li>Global Descriptor Table (GDT)</li>
<li>Interrupt Descriptor Table (IDT)</li>
<li>System images (<code>ntoskrnl.exe</code>, <code>ndis.sys</code>, <code>hal.dll</code>)</li>
<li>Processor MSRs (syscall)</li>
</ul>
<p>但是微软同样提供了一些对象回调函数的接口，供安全厂商来使用，来监控一些操作，称为内核模式通知，利用该回调可以实现对对象请求的过滤保护自身的进程，目前大部分64位下的安全软件保护机制都是基于该方法</p>
<p>监控了一些更加常见的事件，包括进程或线程的创建、终止以及image&#x2F;DLL 的内存加载。</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220729154941445.png" alt="image-20220729154941445"></p>
<h1 id="0x01-Bypass"><a href="#0x01-Bypass" class="headerlink" title="0x01 Bypass"></a>0x01 Bypass</h1><p>由于微软并没有提供一个内核组建的合法方式来接受内存操作的提醒，所以现在的安全厂商都使用了用户态的hook来检测恶意操作。所以直接使用syscall使得bypass成为了可能，下面列出几种bypass方式</p>
<h2 id="1-Export-Address-Table-EAT"><a href="#1-Export-Address-Table-EAT" class="headerlink" title="1.Export Address Table(EAT)"></a>1.Export Address Table(EAT)</h2><p>之前我们调用一些未公开的内核函数比如NtCreatThreadEx时，会使用GetModuleHandle和GetProcAddress。这种方式同样会被用户态hook检测，因为这两个方法在用户态，非常容易被检测到，那么就可以通过PEB表来定位ntdll.dll的地址，然后通过解析ntdll.dll的EAT表来获取其导出函数</p>
<p>一个通过DLL首地址和函数名来定位导出函数地址的demo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> LPVOID WINAPI <span class="title function_">GetProcAddressFromEAT</span><span class="params">(</span></span><br><span class="line"><span class="params">    LPVOID DllBase, </span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *FunctionName)</span></span><br><span class="line">&#123;</span><br><span class="line">    PIMAGE_DOS_HEADER       DosHeader;</span><br><span class="line">    PIMAGE_NT_HEADERS       NtHeaders;</span><br><span class="line">    DWORD                   NumberOfNames, VirtualAddress;</span><br><span class="line">    PIMAGE_DATA_DIRECTORY   DataDirectory;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY ExportDirectory;</span><br><span class="line">    PDWORD                  Functions;</span><br><span class="line">    PDWORD                  Names;</span><br><span class="line">    PWORD                   Ordinals;</span><br><span class="line">    PCHAR                   Name;</span><br><span class="line">    LPVOID                  ProcAddress=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    DosHeader      = (PIMAGE_DOS_HEADER)DllBase;</span><br><span class="line">    NtHeaders      = RVA2VA(PIMAGE_NT_HEADERS, DllBase, DosHeader-&gt;e_lfanew);</span><br><span class="line">    DataDirectory  = (PIMAGE_DATA_DIRECTORY)NtHeaders-&gt;OptionalHeader.DataDirectory;</span><br><span class="line">    VirtualAddress = DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (VirtualAddress==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    ExportDirectory = RVA2VA(PIMAGE_EXPORT_DIRECTORY, DllBase, VirtualAddress);</span><br><span class="line">    NumberOfNames   = ExportDirectory-&gt;NumberOfNames;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NumberOfNames==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Functions = RVA2VA(PDWORD,DllBase, ExportDirectory-&gt;AddressOfFunctions);</span><br><span class="line">    Names     = RVA2VA(PDWORD,DllBase, ExportDirectory-&gt;AddressOfNames);</span><br><span class="line">    Ordinals  = RVA2VA(PWORD, DllBase, ExportDirectory-&gt;AddressOfNameOrdinals);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      Name = RVA2VA(PCHAR, DllBase, Names[NumberOfNames<span class="number">-1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(lstrcmpA(Name, FunctionName) == <span class="number">0</span>) &#123;</span><br><span class="line">        ProcAddress = RVA2VA(LPVOID, DllBase, Functions[Ordinals[NumberOfNames<span class="number">-1</span>]]);</span><br><span class="line">        <span class="keyword">return</span> ProcAddress;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--NumberOfNames &amp;&amp; ProcAddress == <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ProcAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子定位一个nt函数之后，可以从函数首地址来遍历查找syscall的地址，然后可以直接使我们的函数直接jmp到syscall地址即可加载系统调用，但是这样存在一个问题，如果ntdll的nt函数已经被hook了，那么可能会存在查找不到syscall的问题，或者存在被AVhook的风险，从而检查到非法的syscall调用，所以这样简单的获取地址后进行调用的方法，实际上没有什么用，那么就需要别的解决办法</p>
<p>所以这里只是提供了一个分析EAT表的方法，使得读取nt函数汇编代码成为了可能，就可以进一步利用我们得到的代码</p>
<h2 id="2-Dual-load"><a href="#2-Dual-load" class="headerlink" title="2.Dual-load"></a>2.Dual-load</h2><p>这个思路就是二次加载ntdll，二次加载了之后，有可能AV&#x2F;EDR只hook了之前加载的ntdll，而没有hook新加载的，所以就可以直接使用新加载的ntdll调用nt函数</p>
<h3 id="Dual-load-1-Section"><a href="#Dual-load-1-Section" class="headerlink" title="Dual-load 1 (Section)"></a>Dual-load 1 (Section)</h3><p>KnownDlls 是对象命名空间中的一个目录，其中包含进程加载的最常见 DLL 的部分对象</p>
<p>存储在注册表<strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</strong>下</p>
<p>它旨在通过减少可执行文件的加载时间来提高性能，并且可以通过打开节名“\KnownDlls\ntdll.dll”将 NTDLL 的新副本映射到进程中。</p>
<p>重新加载之后，我们就相当于获取了一个未被hook的ntdll对象，就可以使用其中的syscall方法了，加载demo如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS          Status;</span><br><span class="line">    LARGE_INTEGER     SectionOffset;</span><br><span class="line">    SIZE_T            ViewSize;</span><br><span class="line">    PVOID             ViewBase;</span><br><span class="line">    HANDLE            SectionHandle;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    UNICODE_STRING    KnownDllsNtDllName;</span><br><span class="line">    FARPROC           Function;</span><br><span class="line">    </span><br><span class="line">    INIT_UNICODE_STRING(</span><br><span class="line">      KnownDllsNtDllName, </span><br><span class="line">      <span class="string">L&quot;\\KnownDlls\\ntdll.dll&quot;</span></span><br><span class="line">      );</span><br><span class="line">    </span><br><span class="line">    InitializeObjectAttributes(</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;KnownDllsNtDllName,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    Status = NtOpenSection(</span><br><span class="line">              &amp;SectionHandle, </span><br><span class="line">              SECTION_MAP_EXECUTE | SECTION_MAP_READ | SECTION_QUERY, </span><br><span class="line">              &amp;ObjectAttributes</span><br><span class="line">              );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!NT_SUCCESS(Status)) &#123;</span><br><span class="line">      SET_LAST_NT_ERROR(Status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Unable to open section %ld\n&quot;</span>, GetLastError());</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the offset to start mapping from.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SectionOffset.LowPart = <span class="number">0</span>;</span><br><span class="line">    SectionOffset.HighPart = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the desired base address and number of bytes to map.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ViewSize = <span class="number">0</span>;</span><br><span class="line">    ViewBase = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Status = NtMapViewOfSection(</span><br><span class="line">              SectionHandle,</span><br><span class="line">              NtCurrentProcess(),</span><br><span class="line">              &amp;ViewBase,</span><br><span class="line">              <span class="number">0</span>,              <span class="comment">// ZeroBits</span></span><br><span class="line">              <span class="number">0</span>,              <span class="comment">// CommitSize</span></span><br><span class="line">              &amp;SectionOffset,</span><br><span class="line">              &amp;ViewSize,</span><br><span class="line">              ViewShare,</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              PAGE_EXECUTE_READ</span><br><span class="line">              );</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">if</span>(!NT_SUCCESS(Status)) &#123;</span><br><span class="line">      SET_LAST_NT_ERROR(Status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Unable to map section %ld\n&quot;</span>, GetLastError());</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Function = (FARPROC)GetProcAddressFromEAT(ViewBase, <span class="string">&quot;NtOpenProcess&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NtOpenProcess : %p, %ld\n&quot;</span>, Function, GetLastError());</span><br><span class="line">    </span><br><span class="line">cleanup:</span><br><span class="line">    <span class="keyword">if</span>(ViewBase != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NtUnmapViewOfSection(</span><br><span class="line">        NtCurrentProcess(), </span><br><span class="line">        ViewBase</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(SectionHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NtClose(SectionHandle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是还存在的问题就是，加载dll的操作还是会产生内核提醒而被AV&#x2F;EDR检测到，从而还有被发现的风险</p>
<h3 id="Dual-load-2-Disk"><a href="#Dual-load-2-Disk" class="headerlink" title="Dual-load 2 (Disk)"></a>Dual-load 2 (Disk)</h3><p>与通过KnownDlls增加新映射意一样，也可以通过文件系统方法来加载</p>
<p>与前一种方法相比，唯一的额外步骤是我们打开 C:\Windows\System32\NTDLL.dll 的文件句柄，并使用它创建一个具有 SEC_IMAGE 页面保护的新节对象</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS          Status;</span><br><span class="line">    LARGE_INTEGER     SectionOffset;</span><br><span class="line">    SIZE_T            ViewSize;</span><br><span class="line">    PVOID             ViewBase=<span class="literal">NULL</span>;</span><br><span class="line">    HANDLE            FileHandle=<span class="literal">NULL</span>, SectionHandle=<span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes;</span><br><span class="line">    IO_STATUS_BLOCK   StatusBlock;</span><br><span class="line">    UNICODE_STRING    FileName;</span><br><span class="line">    FARPROC           Function;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Try open ntdll.dll on disk for reading.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    INIT_UNICODE_STRING(</span><br><span class="line">      FileName, </span><br><span class="line">      <span class="string">L&quot;\\??\\C:\\Windows\\System32\\ntdll.dll&quot;</span></span><br><span class="line">      );</span><br><span class="line">    </span><br><span class="line">    InitializeObjectAttributes(</span><br><span class="line">        &amp;ObjectAttributes,</span><br><span class="line">        &amp;FileName,</span><br><span class="line">        OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    Status = NtOpenFile(</span><br><span class="line">              &amp;FileHandle, </span><br><span class="line">              FILE_READ_DATA, </span><br><span class="line">              &amp;ObjectAttributes,</span><br><span class="line">              &amp;StatusBlock, </span><br><span class="line">              FILE_SHARE_READ, </span><br><span class="line">              <span class="literal">NULL</span></span><br><span class="line">              );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!NT_SUCCESS(Status)) &#123;</span><br><span class="line">      SET_LAST_NT_ERROR(Status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NtOpenFile failed %ld\n&quot;</span>, GetLastError());</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Create section</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = NtCreateSection(</span><br><span class="line">              &amp;SectionHandle, </span><br><span class="line">              SECTION_ALL_ACCESS, </span><br><span class="line">              <span class="literal">NULL</span>, </span><br><span class="line">              <span class="literal">NULL</span>, </span><br><span class="line">              PAGE_READONLY, </span><br><span class="line">              SEC_IMAGE, </span><br><span class="line">              FileHandle</span><br><span class="line">              );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!NT_SUCCESS(Status)) &#123;</span><br><span class="line">      SET_LAST_NT_ERROR(Status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NtCreateSection failed %ld\n&quot;</span>, GetLastError());</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the offset to start mapping from.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SectionOffset.LowPart = <span class="number">0</span>;</span><br><span class="line">    SectionOffset.HighPart = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Set the desired base address and number of bytes to map.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ViewSize = <span class="number">0</span>;</span><br><span class="line">    ViewBase = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    Status = NtMapViewOfSection(</span><br><span class="line">              SectionHandle,</span><br><span class="line">              NtCurrentProcess(),</span><br><span class="line">              &amp;ViewBase,</span><br><span class="line">              <span class="number">0</span>,              <span class="comment">// ZeroBits</span></span><br><span class="line">              <span class="number">0</span>,              <span class="comment">// CommitSize</span></span><br><span class="line">              &amp;SectionOffset,</span><br><span class="line">              &amp;ViewSize,</span><br><span class="line">              ViewShare,</span><br><span class="line">              <span class="number">0</span>,</span><br><span class="line">              PAGE_EXECUTE_READ</span><br><span class="line">              );</span><br><span class="line">              </span><br><span class="line">    <span class="keyword">if</span>(!NT_SUCCESS(Status)) &#123;</span><br><span class="line">      SET_LAST_NT_ERROR(Status);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Unable to map section %ld\n&quot;</span>, GetLastError());</span><br><span class="line">      <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Function = (FARPROC)GetProcAddressFromEAT(ViewBase, <span class="string">&quot;NtOpenProcess&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NtOpenProcess : %p, %ld\n&quot;</span>, Function, GetLastError());</span><br><span class="line">    </span><br><span class="line">cleanup:</span><br><span class="line">    <span class="keyword">if</span>(ViewBase != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NtUnmapViewOfSection(</span><br><span class="line">        NtCurrentProcess(), </span><br><span class="line">        ViewBase</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(SectionHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NtClose(SectionHandle);</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(FileHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      NtClose(FileHandle);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-Extracting-SSN-Code-Stub"><a href="#3-Extracting-SSN-Code-Stub" class="headerlink" title="3.Extracting SSN Code Stub"></a>3.Extracting SSN Code Stub</h2><p>SSN（System Service Number）系统服务号，代表着每个系统调用的编号，syscall就是根据不同的编号来进行不同的操作</p>
<p>不同win版本之间的系统调用号都有些区别，需要根据操作系统版本来取得相应的SSN号</p>
<p>这个思路就是通过提取出ntdll中每个syscall的SSN号，从而保存下来，之后我们可以直接手动调用或进行其他的操作</p>
<p>通过x64dbg查看ntdll中导出函数的汇编代码</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801164846623.png" alt="image-20220801164846623"></p>
<p>可以看到其中的<code>mov eax,4E</code>，就是将NtCreateThread的对应SSN存入eax中，然后使用syscall，会从eax中取出SSN进行对应的系统调用操作</p>
<p>就可以使用遍历ntdll的EAT的方式来获取全部nt或zw函数的SSN</p>
<h3 id="Extracting-SSN-Code-Stub-Disk"><a href="#Extracting-SSN-Code-Stub-Disk" class="headerlink" title="Extracting SSN Code Stub (Disk)"></a>Extracting SSN Code Stub (Disk)</h3><p>这个思路就是从磁盘中重新加载一个ntdll，读取它来获取所需要的信息</p>
<p>打开 C:\Windows\System32\NTDLL.dll 的文件句柄。创建并映射具有 SEC_COMMIT 和 PAGE_READONLY 页面保护的节对象，然后通过解析 PE 标头并将调用存根复制到可执行内存来解决攻击者需要的系统调用</p>
<h3 id="Extracting-SSN-Disk"><a href="#Extracting-SSN-Disk" class="headerlink" title="Extracting SSN (Disk)"></a>Extracting SSN (Disk)</h3><p>这个与上述思路差不多，主要区别就是，不使用ntdll中的代码存根了，而是我们提取每个系统调用号之后，使用我们自己的代码存根实现syscall的功能</p>
<p><a target="_blank" rel="noopener" href="https://github.com/hfiref0x/SyscallTables">SyscallTables</a> 这个项目储存了获取的syscall系统服务号,</p>
<p><a target="_blank" rel="noopener" href="https://github.com/am0nsec/HellsGate">Hell’s Gate：地域之门</a> 使用它实现了这个功能</p>
<p>原理：通过直接读取进程第二个导入模块即NtDLL，解析结构然后遍历导出表，根据函数名Hash找到函数地址，将这个函数读取出来通过<code>0xb8</code>这个操作码来动态获取对应的系统调用号，从而绕过内存监控，在自己程序中执行了NTDLL的导出函数而不是直接通过<code>LoadLibrary</code>然后<code>GetProcAddress</code></p>
<p>还有几个其他的项目基于地狱之门进行了改进</p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1464/#toc_halos-gate">Halo’s Gate：光环之门</a></p>
<p>原理：地狱之门实现了动态的系统调用，amazing，但也有一点缺点，如果访问的那块内存不是ntdll.dll呢，即ntdll.dll被修改了，Nt*函数被hook。这个时候地狱之门就会失效，这个时候出现了光环之门，EDR不可能HOOK全部的Nt*函数，总有一些不敏感的函数没有被HOOK，程序当中以STUB_SIZE(这个长度为32)上下循环遍历，找到没有被HOOK的STUB后获取其系统调用号再减去移动的步数，就是所要搜索的系统调用号。这种方式的优点是可以避免所要搜索的函数被hook之后，程序直接返回。</p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1464/#toc_tartarusgate">TartarusGate：塔耳塔洛斯之门</a></p>
<p>这个项目的作者声称是对光环之门的加强，只是检测第一个字节和第四个字节是否是0xe9，来判断函数是否被hook，个人感觉意义并不是很大，在光环之门中已经实现了 遍历相邻的Nt*函数来搜索系统调用号，多出来的check字节，有点锦上添花。</p>
<p><a target="_blank" rel="noopener" href="https://tttang.com/archive/1464/#toc_spoofing-gate">Spoofing-Gate：欺骗之门</a></p>
<p>主要原理是当使用halos gate&#x2F;hells gate获取到sysid后 从ntdll中随机选择未用到的Nt api，  替换其sysid为获取到的sysid即可直接call。 在设计上面调用时加入了一个排除项可以输入[]string类型以避免api调用冲突，  内置的Nt api list已经排除了EDRs项目中被hook的api ，内置的Nt api list排除了部分可能影响到正常执行的api  返回的结构体实现了Revover()函数可以直接恢复原sysid  。缺点是必须修改ntdll，有两种方式：(NtProtect+memcpy&#x2F;WriteProcessMemory)  作者选用的是后者，在写入前后会自动修改protect值</p>
<h2 id="4-Sorting-by-System-Call-Address"><a href="#4-Sorting-by-System-Call-Address" class="headerlink" title="4.Sorting by System Call Address"></a>4.Sorting by System Call Address</h2><p>这里又提出了一个新的思路，不需要二次加载ntdll，也不需要保存每个操作系统对应的SSN，它实现起来相对简单，应该可以在所有版本的 Windows 上成功运行</p>
<p>之前进行的操作都是想办法来获取syscall的调用SSN号，都会从汇编代码中读取，实际上系统调用号的排序是有规律的，是根据zw或nt函数的顺序进行排序的</p>
<p>使用x64dbg查看nt函数</p>
<p>可以看到nt函数地址最小的函数的SSN编号为0</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172012539.png" alt="image-20220801172012539"></p>
<p>然后接下来地址的SSN将会根据地址顺序依次递加</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172141933.png" alt="image-20220801172141933"></p>
<p>并且实际上zw开头的函数和nt开头的函数地址是一样的，是等价的</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220801172425335.png" alt="image-20220801172425335"></p>
<p>所以就得出结论</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.实际上所有的Zw函数和Nt同名函数实际上是等价的</span><br><span class="line">2.系统调用号实际上是和Zw函数按照地址顺序的排列是一样的</span><br></pre></td></tr></table></figure>

<p>因此我们就只需要遍历所有Zw函数，记录其函数名和函数地址，最后将其按照函数地址升序排列后，每个函数的SSN就是其对应的排列顺序，如下两个项目都使用了这种方法，来兼容不同的操作系统版本，效果很好</p>
<p><a target="_blank" rel="noopener" href="https://github.com/crummie5/FreshyCalls">FreshyCalls</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/jthuraisamy/SysWhispers2">Syswhispers2</a> </p>
<p>又出现了新的 <a target="_blank" rel="noopener" href="https://tttang.com/archive/1464/#toc_syswhispers3">SysWhispers3</a> ，重点解决了 SysWhisper2中syscall指令被查杀，syscall不是从ntdll发出这两个问题。</p>
<p>这里可以与之前的项目比较，其中有个叫EGG的手段，先用垃圾指令替代syscall，在运行的时候从内存中找出来替换syscall。</p>
<p>前面也提到了，可以用int2e来替换syscall指令，但AV也不是傻子，加一条规则就可以检测到。</p>
<p>这里的egg hunt，使用“DB”来定义一个字节的汇编指令</p>
<p>但是syswhispers3解决的主要问题是syscall不是从ntdll发出这个问题</p>
<p>我们如果自实现了syscall代码存根，从而直接在我们的程序中调用syscall的话，其实和在ntdll中调用流程是不一样的，不一样的点就在于RIP指针所指的地址不同</p>
<p>，即在哪实现的syscall，RIP最终返回地址就会指向哪里，这里给出使用ntdll和自实现存根的不同</p>
<p>使用ntdll正常调用</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/normal-api-flow.png" alt="Normal API Flow"></p>
<p>而我们自实现调用</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/crafted-syscall-flow.png" alt="Crafted Syscall Flow"></p>
<p>所以如果来检测从内核态切换到用户态时的返回地址，那么就会被发现自实现syscall</p>
<p>那么提供的方案就是，在我们自实现的存根中不使用syscall指令，而是在原来指令的地方直接使用jmp跳转到ntdll中的某的syscall指令地址直接执行，此时返回地址就是ntdll中的地址，并且使用动态查找的方式来定位syscall指令，而不是使用静态偏移，避免如果被hook的情况下查找不到的情况</p>
<p>但是这样的方法还是可能会被检测到：</p>
<p>因为不管怎么样使用syscall，还是会进入内核执行对应SSN的系统调用，那么只要根据SSN来检测进行的系统调用，就知道执行了什么函数，所以上面的RIP检测只是一种比较浅层的检测方式，可以使用 ETW 关联返回地址（从内核返回）以识别我们使用的系统调用，所以说只要进行了系统调用，都可以通过利用内核跟踪来检测，功与防是相对的，这就需要恶意软件不要进行太频繁的系统调用，从而减少杀软的怀疑</p>
<p>细说一下前面说到的混淆手法：</p>
<p><strong>使用<code>int 2Eh</code>代替<code>syscall</code></strong></p>
<p>来源<a target="_blank" rel="noopener" href="https://captmeelo.com/redteam/maldev/2021/11/18/av-evasion-syswhisper.html">https://captmeelo.com/redteam/maldev/2021/11/18/av-evasion-syswhisper.html</a></p>
<p>实际上就是简单的替换指令，使用int 2Eh避开对于syscall的检测，由于太简单，实际上加上int 2Eh的检测即可</p>
<p><strong>Egg Hunting</strong> </p>
<p>就是编写代码时不直接写syscall，防止静态检测，然后动态运行时将填入的垃圾字节替换成syscall再执行，就是前面<a target="_blank" rel="noopener" href="https://tttang.com/archive/1464/#toc_syswhispers3">SysWhispers3</a>使用的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NtAllocateVirtualMemory PROC</span><br><span class="line">  mov [rsp +8], rcx          ; Save registers.</span><br><span class="line">  mov [rsp+16], rdx</span><br><span class="line">  mov [rsp+24], r8</span><br><span class="line">  mov [rsp+32], r9</span><br><span class="line">  sub rsp, 28h</span><br><span class="line">  mov ecx, 003970B07h        ; Load function hash into ECX.</span><br><span class="line">  call SW2_GetSyscallNumber  ; Resolve function hash into syscall number.</span><br><span class="line">  add rsp, 28h</span><br><span class="line">  mov rcx, [rsp +8]          ; Restore registers.</span><br><span class="line">  mov rdx, [rsp+16]</span><br><span class="line">  mov r8, [rsp+24]</span><br><span class="line">  mov r9, [rsp+32]</span><br><span class="line">  mov r10, rcx</span><br><span class="line">  DB 77h                     ; &quot;w&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 74h                     ; &quot;t&quot;</span><br><span class="line">  DB 77h                     ; &quot;w&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 0h                      ; &quot;0&quot;</span><br><span class="line">  DB 74h                     ; &quot;t&quot;</span><br><span class="line">  ret</span><br><span class="line">NtAllocateVirtualMemory ENDP</span><br></pre></td></tr></table></figure>

<p>之后动态匹配到填充字段之后，使用syscall替换即可，完整可以替换为syscall; ret; nop; nop; nop; nop; nop;</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/29/TEB&PEB%E8%A1%A8%E5%AD%A6%E4%B9%A0/" rel="prev" title="TEB表&PEB表&LDR链学习">
      <i class="fa fa-chevron-left"></i> TEB表&PEB表&LDR链学习
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/08/02/DNS_rebinding/" rel="next" title="DNS_rebinding">
      DNS_rebinding <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0x00-%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#0x01-Bypass"><span class="nav-number">2.</span> <span class="nav-text">0x01 Bypass</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Export-Address-Table-EAT"><span class="nav-number">2.1.</span> <span class="nav-text">1.Export Address Table(EAT)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Dual-load"><span class="nav-number">2.2.</span> <span class="nav-text">2.Dual-load</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dual-load-1-Section"><span class="nav-number">2.2.1.</span> <span class="nav-text">Dual-load 1 (Section)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dual-load-2-Disk"><span class="nav-number">2.2.2.</span> <span class="nav-text">Dual-load 2 (Disk)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Extracting-SSN-Code-Stub"><span class="nav-number">2.3.</span> <span class="nav-text">3.Extracting SSN Code Stub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Extracting-SSN-Code-Stub-Disk"><span class="nav-number">2.3.1.</span> <span class="nav-text">Extracting SSN Code Stub (Disk)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extracting-SSN-Disk"><span class="nav-number">2.3.2.</span> <span class="nav-text">Extracting SSN (Disk)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Sorting-by-System-Call-Address"><span class="nav-number">2.4.</span> <span class="nav-text">4.Sorting by System Call Address</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ka1t4v"
      src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/config/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ka1t4v</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ka1t4v" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ka1t4v" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ka1t4v@gmail.com" title="E-Mail → mailto:ka1t4v@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ka1t4v</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
