<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ka1t4v.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="0x00 前言 最近在学习入门Windows安全，于是就想写文章来记录一下自己的学习过程，从最基本的WindowsAPI出发，然后再到具体的dll注入技术">
<meta property="og:type" content="article">
<meta property="og:title" content="Windows DLL注入">
<meta property="og:url" content="https://ka1t4v.github.io/2022/07/26/Windows_dll%E6%B3%A8%E5%85%A5/index.html">
<meta property="og:site_name" content="Ka1t4v">
<meta property="og:description" content="0x00 前言 最近在学习入门Windows安全，于是就想写文章来记录一下自己的学习过程，从最基本的WindowsAPI出发，然后再到具体的dll注入技术">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710003718870.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709162912290.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709163114543.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709165706638.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709163457044.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709173927445.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174230739.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174159134.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174337153.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709164858320.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713142218817.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709182858153.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709183152404.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709183210678.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712133017692.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709230011353.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233030499.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224351608.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224612215.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224756219.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224840496.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233152603.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233231092.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709235618763.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710000328302.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710000357292.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710005036478.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232552730.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232618940.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232910828.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234621422.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234703428.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234732488.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712193332083.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712134051853.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712140602771.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712170439067.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712170522308.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712174315872.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712174839650.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712180939021.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185702496.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185808715.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185838341.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712194354808.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222041955.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222130082.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222156115.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222243845.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713015148362.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713030105998.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135707934.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135038212.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135355943.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713165228860.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713165403944.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170055276.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170126841.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170535194.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170730318.png">
<meta property="og:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713171010833.png">
<meta property="article:published_time" content="2022-07-26T14:46:25.000Z">
<meta property="article:modified_time" content="2023-03-13T08:39:42.241Z">
<meta property="article:author" content="Ka1t4v">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710003718870.png">

<link rel="canonical" href="https://ka1t4v.github.io/2022/07/26/Windows_dll%E6%B3%A8%E5%85%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Windows DLL注入 | Ka1t4v</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ka1t4v</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://ka1t4v.github.io/2022/07/26/Windows_dll%E6%B3%A8%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/config/avatar.jpg">
      <meta itemprop="name" content="Ka1t4v">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ka1t4v">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Windows DLL注入
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-07-26 22:46:25" itemprop="dateCreated datePublished" datetime="2022-07-26T22:46:25+08:00">2022-07-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Windows/" itemprop="url" rel="index"><span itemprop="name">Windows</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1>0x00 前言</h1>
<p>最近在学习入门Windows安全，于是就想写文章来记录一下自己的学习过程，从最基本的WindowsAPI出发，然后再到具体的dll注入技术</p>
<span id="more"></span>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/">Windows官方API手册参考</a></p>
<p>本文中用到的工具：</p>
<p>Visual Studio 2019</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-246459-1.htm">StudyPE</a>（查看PE文件结构，本文用来查看输入表）</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-224408.htm">AheadLib</a>（实现DLL劫持工具）</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">ProcessExplorer</a>（查看运行中的进程，本文用来查看运行程序加载的DLL）</p>
<h1>0x01 DLL注入原理</h1>
<p>那么首先需要知道什么是DLL，维基百科定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动态链接库（英语：Dynamic-link library，缩写为DLL）是微软公司在windows系统中实现共享函数库概念的一种实现方式。这些库函数的扩展名是.DLL、.OCX（包含ActiveX控制的库）或者.DRV（旧式的系统驱动程序）。所谓动态链接，就是把一些经常会共享的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载存储器内，DLL档本身的结构就是可执行档，当程序有需求时函数才进行链接。通过动态链接方式，存储器浪费的情形将可大幅降低。静态链接库则是直接链接到可执行文件。DLL的文件格式与视窗EXE文件一样——也就是说，等同于32位视窗的可移植执行文件（PE）和16位视窗的New Executable（NE）。作为EXE格式，DLL可以包括源代码、数据和资源的多种组合。                                                        </span><br></pre></td></tr></table></figure>
<p>那么简单来说DLL就是Windows平台提供的一种模块共享和重用的机制，它本身不能直接独立执行，但可以被加载到其他进程中间接执行，对灵活实现各种补丁功能非常有帮助</p>
<p>DLL注入（英语：DLL  injection）是一种计算机编程技术，它可以强行使另一个进程加载一个动态链接库以在其地址空间内运行指定代码。在Windows操作系统上，每个进程都有独立的进程空间，即一个进程是无法直接操作另一个进程的数据的（事实上，不仅Windows，许多操作系统也是如此）。但是DLL注入是用一种不直接的方式，来实现操作其他进程的数据。假设我们有一个DLL文件，里面有操作目标进程数据的程序代码逻辑，DLL注入就是使目标进程加载这个DLL，加载后，这个DLL就成为目标进程的一部分，目标进程的数据也就可以直接操作了</p>
<p>在通常情况下，程序加载DLL的时机主要有以下三点：</p>
<ul>
<li>
<p>在进程创建阶段加载输入表中的DLL</p>
</li>
<li>
<p>通过调用LoadLibrary（Ex）主动加载</p>
</li>
<li>
<p>由于系统机制的要求，必须加载系统预设的一些基础服务模块，例如输入法模块</p>
</li>
</ul>
<p>因此进行DLL注入时，也是在这三个时机点进行注入的，后文也会将注入分为三类，来具体说明每类注入方式的实现</p>
<p>当一个程序根据输入表或者调用LoadLibrary来加载一个dll时，windows会以以下顺序来搜索指定的dll文件，如果最后没有搜索到，则会报错无法找到DLL</p>
<p>官方文档描述：</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710003718870.png" alt="image-20220710003718870"></p>
<ol>
<li>正在加载DLL的进程的可执行文件的目录</li>
<li>正在加载DLL的进程的当前目录</li>
<li>Windows系统文件夹（可以通过GetSystemDirectory函数来获得系统文件夹目录）我的测试环境下为C:\Windows\system32</li>
<li>Windows文件夹（可以通过GetWindowsDirectory函数来获得文件夹目录）我的测试环境下为C:\Windows</li>
</ol>
<p>DLL加载时的搜索顺序同样是一个需要了解的知识点，会在之后的DLL注入中用到这个知识点进行注入</p>
<h1>0x02 基础WindowsAPI</h1>
<p>首先学习一下注入操作中需要用到的API</p>
<p><strong>LoadLibrary</strong></p>
<p>用来加载一个DLL，将一个指定的DLL映射到调用进程的地址空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HINSTANCE <span class="title">LoadLibrary</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">LPCTSTR lpLibFileName</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>lpLibFileName</p>
<p>指定一个想要加载的DLL路径，可以是绝对路径将直接进行加载，如果只传入了文件名，则会按默认顺序进行搜索</p>
</li>
</ul>
<p>返回值：加载DLL的句柄</p>
<p>注：这里说一下可能有时候看到LoadLibraryA和LoadLibraryW，其实这两个函数分别代表者传入DLL路径的编码方式LoadLibraryA代表传入路径是以正常的acsii码编码的，即传入一个普通字符串，比如<code>&quot;test.dll&quot;</code>，而LoadLibraryW代表传入路径是以unicode双字节编码的，在传入的时候需要在字符串前加上L，比如<code>L&quot;test.dll&quot;</code>，如果直接使用LoadLibrary那么默认代表LoadLibraryW所以需要传入双字节字符串，如果直接调用LoadLibraryA则就可以传入一个普通字符串，但实际上LoadLibraryA内部会将字符串转换成unicode编码，然后再调用LoadLibraryW，相当于做了一层封装，本文使用LoadLibrary</p>
<p><strong>GetProcAddress</strong></p>
<p>用来获得加载DLL的函数指针，以用来调用导出函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">LPCSTR lpProcName </span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>hModule</p>
<p>传入之前加载的DLL模块句柄，由LoadLibrary方法获得</p>
</li>
<li>
<p>lpProcName</p>
<p>想要获得导出函数名称</p>
</li>
</ul>
<p>返回值：导出函数的函数指针</p>
<p><strong>OpenProcess</strong></p>
<p>打开现有的本地进程对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL  bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwProcessId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>dwDesiredAccess</p>
<p>标志位代表打开进程的权限，一般获取全部权限就使用<code>PROCESS_ALL_ACCESS</code></p>
</li>
<li>
<p>bInheritHandle</p>
<p>如果该值为 TRUE，则由该进程创建的进程将继承句柄。否则，进程不会继承此句柄</p>
</li>
<li>
<p>dwProcessId</p>
<p>要打开进程的PID</p>
</li>
</ul>
<p>返回值：目标进程的句柄</p>
<p><strong>OpenThread</strong></p>
<p>打开现有的本地线程对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] BOOL  bInheritHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>dwDesiredAccess</p>
<p>标志位代表打开线程的权限，一般如果获得线程全部权限就用<code>THREAD_ALL_ACCESS</code></p>
</li>
<li>
<p>bInheritHandle</p>
<p>和打开进程一样，代表是否继承进程句柄</p>
</li>
<li>
<p>dwThreadId</p>
<p>要打开的线程的标识符</p>
</li>
</ul>
<p>返回值：目标线程的句柄</p>
<p><strong>VirtualAllocEx</strong></p>
<p>在指定进程内存空间分配一块内存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flAllocationType,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           DWORD  flProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>hProcess</p>
<p>进程的句柄，该函数在该进程的虚拟地址空间内分配内存</p>
</li>
<li>
<p>lpAddress</p>
<p>为要分配的页面区域指定所需起始地址的指针，如果 lpAddress 为 NULL，则由该函数确定分配区域的位置</p>
</li>
<li>
<p>dwSize</p>
<p>要分配的内存区域的大小，以字节为单位</p>
</li>
<li>
<p>flAllocationType</p>
<p>内存分配的类型，此参数必须包含以下值之一</p>
<p>MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储</p>
<p>MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储</p>
<p>MEM_RESET：指明在内存中由参数lpAddress和dwSize指定的数据无效</p>
<p>MEM_RESET_UNDO：MEM_RESET_UNDO 只能在之前成功应用 MEM_RESET 的地址范围上调用，它表示调用者对 lpAddress 和 dwSize 指定的指定内存范围内的数据感兴趣，并尝试反转 MEM_RESET 的效果</p>
</li>
<li>
<p>flProtect</p>
<p>要分配的页面区域的内存保护类型，一般使用<code>PAGE_READWRITE</code></p>
</li>
</ul>
<p>返回值：如果分配成功则返回分配内存的起始地址，如果失败返回NULL</p>
<p><strong>WriteProcessMemory</strong></p>
<p>将数据写入指定进程中的内存区域。要写入的整个区域必须可访问，否则操作将失败</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  HANDLE  hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPVOID  lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  LPCVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  SIZE_T  nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] SIZE_T  *lpNumberOfBytesWritten</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>hProcess</p>
<p>要修改的进程内存的句柄</p>
</li>
<li>
<p>lpBaseAddress</p>
<p>指向要写入数据的指定进程中的基地址的指针</p>
</li>
<li>
<p>lpBuffer</p>
<p>指向缓冲区的指针，该缓冲区包含要写入指定进程地址空间的数据</p>
</li>
<li>
<p>nSize</p>
<p>要写入指定进程的字节数</p>
</li>
<li>
<p>*lpNumberOfBytesWritten</p>
<p>指向变量的指针，该变量接收传输到指定进程的字节数。此参数是可选的。如果 lpNumberOfBytesWritten 为 NULL，则忽略该参数</p>
</li>
</ul>
<p>返回值：如果写入成功返回值非0，如果失败则返回值为0</p>
<p><strong>CreateToolhelp32Snapshot</strong></p>
<p>拍摄指定进程的快照，以及这些进程使用的堆、模块和线程，用来枚举所有这些信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>dwFlags</p>
<p>指定快照类型，可以是以下一个或多个类型</p>
<p>TH32CS_INHERIT：指示快照句柄是可继承的</p>
<p>TH32CS_SNAPALL：包括系统中的所有进程和线程，以及 th32ProcessID 中指定的进程的堆和模块</p>
<p>TH32CS_SNAPHEAPLIST：包括快照中 th32ProcessID 中指定的进程的所有堆</p>
<p>TH32CS_SNAPMODULE：包括快照中 th32ProcessID 中指定的进程的所有模块</p>
<p>TH32CS_SNAPMODULE32：当从 64 位进程调用时，包括快照中 th32ProcessID 中指定的进程的所有 32 位模块</p>
<p>TH32CS_SNAPPROCESS：在快照中包括系统中的所有进程</p>
<p>TH32CS_SNAPTHREAD：在快照中包括系统中的所有线程</p>
</li>
<li>
<p>th32ProcessID</p>
<p>要包含在快照中的进程的进程标识符，此参数可以为零以指示当前进程，只有当指定 TH32CS_SNAPHEAPLIST、TH32CS_SNAPMODULE、TH32CS_SNAPMODULE32 或 TH32CS_SNAPALL 值时使用此参数。否则，它将被忽略并且所有进程都包含在快照中</p>
</li>
</ul>
<p>返回值：如果函数成功，它将返回指定快照的打开句柄</p>
<p>然后就可以使用Process32First/Process32Next遍历进程，或使用Thread32First/Thread32Next遍历线程，Heap32ListFirst/Heap32ListNext遍历堆，Module32First/Module32Next遍历模块</p>
<h1>0x03 使用VS2019来写一个DLL</h1>
<p>学习注入前首先要学习如何来写一个dll</p>
<p>VS版本：Community 2019</p>
<p>工作负荷只选了这两个</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709162912290.png" alt="image-20220709162912290"></p>
<p>使用动态链接库（DLL）模板创建DLL项目，会自动生成pch预编译头和一个简单的dll模板</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709163114543.png" alt="image-20220709163114543"></p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709165706638.png" alt="image-20220709165706638"></p>
<p>创建完成后的的目录结构</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709163457044.png" alt="image-20220709163457044"></p>
<p>主要来看一下dllmain.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子就创建了一个简单的DLL模板，编译dll时需要注意选择x64还是x86</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709173927445.png" alt="image-20220709173927445"></p>
<p><strong>注：64位软件只能注入x64的dll，32位软件只能注入x86的dll，在编译dll前要选择正确的格式，选择不正确会造成注入失败（之前就选择错误踩坑了）</strong></p>
<p>然后点击本地Windows调试器进行编译，会弹出错误提示，没有关系，不影响dll的生成</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174230739.png" alt="image-20220709174230739"></p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174159134.png" alt="image-20220709174159134"></p>
<p>最后dll生成在当前项目根目录中的Debug文件夹下</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709174337153.png" alt="image-20220709174337153"></p>
<p>但是写DLL前，还需要对DLL文件的结构有一个初步的了解，以下内容对DLL的一些必要方法进行解释</p>
<h2 id="DLLMain函数"><a class="header-anchor" href="#DLLMain函数">¶</a>DLLMain函数</h2>
<p>看到模板自动生成了DLLMain函数，那么这个函数有什么作用呢，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/previous-versions/ms939455(v=msdn.10)">官方手册定义</a></p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709164858320.png" alt="image-20220709164858320"></p>
<p>那么就可以知道，DLLMain是一个DLL文件的入口，在使用LoadLibrary和FreeLibrary都会调用DllMain函数。即加载和卸载DLL时都会自动执行DLLMain函数，那么这个机制就提供给了恶意代码一个可乘之机，只要将DLL注入到目标中加载，那么就会自动执行DLLMain中的代码。</p>
<p>DLLMain的三个参数：</p>
<ul>
<li>
<p>HANDLE hinstDLL：指向自身的句柄</p>
</li>
<li>
<p>DWORD dwReason：调用DLL的原因</p>
<p>可以看到前面自动生成的模板中对于调用原因进行了switch判断，分为四个调用原因，分别为</p>
<ol>
<li>DLL_PROCESS_ATTACH：由于进程启动或调用 LoadLibrary时会出现这个dwReason字段，即代表着DLL 正在加载到当前进程的虚拟地址空间，那么就可以理解为使用LoadLibrary或LoadLibraryEX方法第一次加载DLL时会产生这个dwReason字段，如果同一个进程后来为已经映射进来的DLL再次调用LoadLibrary或者LoadLibraryEx，操作系统只会增加DLL的使用次数，它不会再用DLL_PROCESS_ATTACH调用DLL的DllMain函数。</li>
<li>DLL_PROCESS_DETACH：当DLL被从进程的地址空间解除映射时，系统调用了它的DllMain，传递的dwReason值是DLL_PROCESS_DETACH。当DLL处理该值时，它应该执行进程相关的清理工作。那可以就可以理解为当进程结束或使用FreeLibrary方法来解除DLL影视时会产生这个dwReason字段</li>
<li>DLL_THREAD_ATTACH：表示当前进程正在创建一个新线程。发生这种情况时，系统会调用当前附加到进程的所有 DLL 的入口点函数。调用是在新线程的上下文中进行的。请注意，只有在进程加载 DLL 后创建的线程才能使用此值调用 DLL 函数的入口点。使用 LoadLibrary 加载 DLL 时，现有线程不会调用新加载的 DLL 的入口点函数。</li>
<li>DLL_THREAD_DETACH：如果线程调用了ExitThread来结束线程（线程函数返回时，系统也会自动调用ExitThread），系统查看当前映射到进程空间中的所有DLL文件映像，并用DLL_THREAD_DETACH来调用DllMain函数，通知所有的DLL去执行线程级的清理工作。</li>
</ol>
</li>
<li>
<p>LPVOID lpvReserved：隐式加载或显式加载</p>
</li>
</ul>
<h2 id="导出DLL函数"><a class="header-anchor" href="#导出DLL函数">¶</a>导出DLL函数</h2>
<p>程序加载DLL之后需要导入DLL提供的导出函数，那么就需要在DLL文件中对于导出函数进行声明</p>
<p>在VS中使用c++编写DLL时，假设需要导出hello()函数，那么只需在函数定义时加上指定的头<code>extern &quot;C&quot; __declspec(dllexport)</code>即可，如下在前面的dllmain.cpp中加上一个导出函数hello()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译完后使用studype就可以看到生成dll的导出函数</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713142218817.png" alt="image-20220713142218817"></p>
<p>程序通过LoadLibrary加载DLL后获得DLL的句柄，然后就可以使用GetProcAddress来获取dll中指定的导出函数句柄，从而调用导出函数</p>
<h2 id="简单DEMO"><a class="header-anchor" href="#简单DEMO">¶</a>简单DEMO</h2>
<p>上文中已经写了一个简单的DLL文件，包含一个导出函数，但是DLLMain函数并没有写东西，这里在DLLMain中同样写一个MessageBox来告知DLLMain函数的执行，由于这里会使用LoadLibrary方法加载DLL，所以需要将MessageBox消息写在DLL_PROCESS_ATTACH下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;DLLMain&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后选择x86格式编译dll，编译完成根目录debug文件夹下生成dll文件</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709182858153.png" alt="image-20220709182858153"></p>
<p>然后写一个简单的dll动态加载的demo</p>
<p>vs创建一个空项目，根据我们生成的DLL的绝对路径来加载</p>
<p><strong>注：此时也可以直接传入文件名进行加载，但是此时需要将DLL放在上文中所说的搜索的四个文件夹中，一般是放在exe同目录下即可</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMod = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;C:\\Users\\13378\\source\\repos\\dll_test\\Debug\\dll_test.dll&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (hMod != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		func hello = (func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;调用导出函数&quot;</span>);</span><br><span class="line">		<span class="built_in">hello</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行，注意此时由于DLL是x86编译的，所以dll加载程序也需要选定x86编译运行</p>
<p>DLLMain初次加载运行</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709183152404.png" alt="image-20220709183152404"></p>
<p>然后主动调用DLL导出函数hello()</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709183210678.png" alt="image-20220709183210678"></p>
<p>简单的DLL加载demo测试成功</p>
<p>接下来根据DLL加载的三个时机，来分别利用不同时机来进行DLL注入，测试环境为本机环境，Windows版本为</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712133017692.png" alt="image-20220712133017692"></p>
<h1>0x04 通过干预输入表处理过程加载目标DLL</h1>
<p>处理并加载输入表中的DLL模块是进程创建阶段一项非常重要的工作。当一个进程被创建后，不会直接到EXE本身的入口处执行，而是会对输入表进行处理，来加载输入表中的模块，这里的输入表在PE文件结构中也叫做导入表，所以只要在输入表被处理之前进行干预，为输入表增加一个项目，使其指向要加载的目标DLL，或者替换原输入表中的DLL并对调用进行转发，那么新的主线程在输入表初始化阶段就会主动加载目标DLL</p>
<p>可以通过工具<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-246459-1.htm">StudyPE</a>来查看输入表，这里以查看notepad.exe为例，可以看到其输入表</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709230011353.png" alt="image-20220709230011353"></p>
<h2 id="静态修改PE输入表法"><a class="header-anchor" href="#静态修改PE输入表法">¶</a>静态修改PE输入表法</h2>
<p>此方法原理就是通过修改PE文件中的输入表，在输入表中加上一条新的输入表项，从而造成额外的DLL加载，造成恶意的DLL注入</p>
<p>输入表结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;  </span><br><span class="line">    _ANONYMOUS_UNION <span class="keyword">union</span> &#123;             </span><br><span class="line">        DWORD Characteristics;  </span><br><span class="line">        DWORD OriginalFirstThunk;   </span><br><span class="line">    &#125; DUMMYUNIONNAME;  </span><br><span class="line">    DWORD TimeDateStamp;                    </span><br><span class="line">    DWORD ForwarderChain;                </span><br><span class="line">    DWORD Name;                           </span><br><span class="line">    DWORD FirstThunk;                     </span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR,*PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<p>该结构简称IID，一个输入表就是一个IID数组，最后一项是全0的（作为结束标志），要实现输入表注入，需要把要注入的DLL构造的结构体塞进输入表里，但是由于输入表默认不是在PE文件的最后，所以输入表原来所在的位置不一定有足够大的空间塞入一个新的结构体，这时我们就需要把输入表移动到新的足够大的位置，现在大体上有两种解决办法</p>
<ul>
<li>拓展最后一个节：直接拓展最后一个节，直接将原来的输入表和插入的输入表项全部复制到拓展节的新空间当中，然后直接在PE头中将导入表地址改成复制后的新地址</li>
<li>增加一个节：原理和拓展节一样，只不过是重新增加了一个节来存放修改后的输入表</li>
</ul>
<p>StudyPE提供了修改输入表的功能：工具-&gt;修改输入表-&gt;增加API函数</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233030499.png" alt="image-20220709233030499"></p>
<p>可以看到支持上述两种插入输入表的方式</p>
<p>注入DLL：还是在DLLMain做一个简单的输出，不一样的就是通过创建线程的方式输出，并且会输出注入进程的路径和pid</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadShow</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> szBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">GetModuleFileNameA</span>(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">    <span class="built_in">sprintf_s</span>(szBuf, <span class="string">&quot;DLL注入到进程%s [pid] = %d&quot;</span>, szPath, <span class="built_in">GetCurrentProcessId</span>());</span><br><span class="line">    <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, szBuf, <span class="string">&quot;DLL Inject&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadShow, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入对象：系统自带的记事本程序notepad.exe（win10）</p>
<p>由于自己的测试环境为win10，在win10下notepad.exe所有者为TrustedInstaller完全控制，管理员账户无法修改notepad.exe文件，所以首先修改一下权限，右键notepad.exe-&gt;属性-&gt;安全</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224351608.png" alt="image-20220709224351608"></p>
<p>然后点击高级，先修改notepad.exe所有者，点击更改之后设置为Administrators</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224612215.png" alt="image-20220709224612215"></p>
<p>然后给予全部控制权限即可</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224756219.png" alt="image-20220709224756219"></p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709224840496.png" alt="image-20220709224840496"></p>
<p>现在就有权限修改notepad.exe文件了，就能够修改其导入表，这里可以直接使用StudyPE工具直接修改导入表</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233152603.png" alt="image-20220709233152603"></p>
<p>选中后进行添加，可以在导入表中看到添加后的新dll和导出函数</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709233231092.png" alt="image-20220709233231092"></p>
<p>然后选择文件-&gt;保存，覆盖原notepad.exe文件（这里提前备份一下原来的notepad.exe，修改完后还原）</p>
<p>然后打开修改后的notepad.exe，显示无法找到我们注入的dll</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220709235618763.png" alt="image-20220709235618763"></p>
<p>报错的原因是因为我们生成的dll在项目根目录，但是这个目录不在系统搜索DLL的目录范围内，所以找不到指定的DLL，这里将生成的DLL放入notepad.exe同目录下即可（搜索DLL顺序在前面DLL注入原理中提过）</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710000328302.png" alt="image-20220710000328302"></p>
<p>再次打开成功注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710000357292.png" alt="image-20220710000357292"></p>
<h2 id="输入表项DLL替换法（DLL劫持法）"><a class="header-anchor" href="#输入表项DLL替换法（DLL劫持法）">¶</a>输入表项DLL替换法（DLL劫持法）</h2>
<p>此方法的原理就是通过替换程序输入表中的加载DLL的具体文件，即可以理解为狸猫换太子，使用恶意DLL来替换真实DLL的文件，造成DLL劫持，假设需要加载的DLL在系统目录下，那么如果伪造一个同名DLL存放在程序同目录下，那么在搜索的时候就会按顺序优先加载伪造DLL，是利用了前面说的DLL搜索顺序</p>
<p>但是根据输入表加载DLL时对于某些关键的DLL文件，不采用正常的搜索顺序在文件系统中查找加载，而是直接通过一个注册表中的设置项<strong>KnownDLLs</strong>，从中进行查找一些关键DLL，它的位置是<strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</strong></p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220710005036478.png" alt="image-20220710005036478"></p>
<p>当需要加载DLL时，系统会优先从KnownDLLs对象目录中查找，如果有的话，直接从这里将其映射到当前进程中，如果没有的话，才会进行搜索</p>
<p>所以除了少数几个核心DLL外，其他DLL尤其是第三方DLL，都可以通过这个办法来劫持</p>
<p>那么总结一下DLL劫持有以下几种实现方式：</p>
<ul>
<li>直接用恶意DLL暴力替换掉正常DLL</li>
<li>利用DLL加载时的搜索顺序，将恶意DLL放在优先级高于正常DLL的目录中</li>
<li>恶意DLL作为中间人，转发正常DLL的导出函数，额外加上其他的恶意操作</li>
</ul>
<p>前两种方法由于最终并没有加载正确的DLL，可能会造成软件崩溃，所以不推荐使用，而第三种方法在保证正常运行的前提下执行恶意代码，有很强的实用性</p>
<p>并且有一个专门用来实现DLL劫持的工具：<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-224408.htm">AheadLib</a>，实现原理就是基于第三种方式</p>
<p>写一个简单的demo来理解DLL劫持</p>
<p>这里还是首先写一个加载dll的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hMod = <span class="built_in">LoadLibrary</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;dll_test.dll&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (hMod != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		func hello = (func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;调用导出函数&quot;</span>);</span><br><span class="line">		<span class="built_in">hello</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后写一个DLL导出一个hello()方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Hello World&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后将DLL放在exe同目录下</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232552730.png" alt="image-20220711232552730"></p>
<p>此时运行test.exe</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232618940.png" alt="image-20220711232618940"></p>
<p>成功加载dll并且调用其导出函数，此时打开AheadLib进行DLL劫持，选中dll_test.dll</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711232910828.png" alt="image-20220711232910828"></p>
<p>此时右边已经生成了劫持DLL的cpp源码，可以看到原理非常简单，只是使用pragma comment加载了原DLL并且导出原DLL的全部导出函数即可，此时只需要将恶意代码写入到DLLMain函数中即可，此时加上一个MessageBox消息代表劫持成功即可</p>
<p>将所给源码编译成一个dll，可以在之前的项目中直接覆盖编译，但是由于dll模板包括了预编译头，所以需要加上<code>#include &quot;pch.h&quot;</code>不然会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 导出函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/EXPORT:hello=dll_testOrg.hello,@1&quot;</span>)</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 入口函数</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">DllMain</span><span class="params">(HMODULE hModule, DWORD dwReason, PVOID pvReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (dwReason == DLL_PROCESS_ATTACH)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;Torjan !!!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">		<span class="built_in">DisableThreadLibraryCalls</span>(hModule);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dwReason == DLL_PROCESS_DETACH)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////</span></span><br></pre></td></tr></table></figure>
<p>源码编译成DLL之后，需要将名字改为被劫持的DLL，并且将被劫持的DLL改为工具中所给出的dll_testOrg.dll，此时将其放在同一目录</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234621422.png" alt="image-20220711234621422"></p>
<p>运行exe，可以看到先执行了劫持DLL的DLLMain函数</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234703428.png" alt="image-20220711234703428"></p>
<p>然后成功调用被劫持DLL的导出函数hello()，成功实现DLL劫持</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220711234732488.png" alt="image-20220711234732488"></p>
<h1>0x05 改变程序运行流程使其主动加载目标DLL</h1>
<p>程序运行的容器是进程，真正活动的是其中的线程。因此，改变程序流程的通常做法是改变线程EIP，创建新线程或修改目标进程内的某些代码，使其执行LoadLibrary来加载目标DLL</p>
<p>技术的核心原理：<br>
我们注入器的进程的内存空间是没办法让目标进程访问到的，而核心调用DLL的基础原理是程序执行<code>LoadLibrary</code>函数去加载指定的DLL，所以我们必须要在目标进程空间存放DLL的文件地址(这样目标进程才能调用到)，由于<code>kernel.dll</code>加载的地址在所有进程都是一样的，且<code>LoadLibrary</code>是其导出模块，其RVA地址是固定在PE结构的，所以注入器获取到的API地址是一样，可作用于目标进程，这样我们就可以通过远程执行目标进程的新线程，然后线程执行<code>LoadLibrary</code>函数加载指定DLL实现DLL注入。</p>
<h2 id="CreatRemoteThread法"><a class="header-anchor" href="#CreatRemoteThread法">¶</a>CreatRemoteThread法</h2>
<p>这是运用非常广泛的一种技术，也叫做远线程注入法，其基本思路就是在目标进程中申请一块内存，并向其写入需要加载的DLL绝对路径，然后调用CreatRemoteThread在目标进程中创建一个新的线程。</p>
<p>CreatRemoteThread官方定义</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712193332083.png" alt="image-20220712193332083"></p>
<p>具体说一下每个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[in] hProcess <span class="comment">//目标进程的句柄</span></span><br><span class="line"></span><br><span class="line">[in] lpThreadAttributes <span class="comment">//一个指向SECURITY_ATTRIBUTES结构的指针，该结构指定了线程的安全属性，一般为NULL</span></span><br><span class="line"></span><br><span class="line">[in] dwStackSize <span class="comment">//线程栈初始大小,以字节为单位，一般为0，代表默认大小</span></span><br><span class="line"></span><br><span class="line">[in] lpStartAddress <span class="comment">//线程执行的函数地址</span></span><br><span class="line"></span><br><span class="line">[in] lpParameter <span class="comment">//执行函数的参数地址</span></span><br><span class="line"></span><br><span class="line">[in] dwCreationFlags <span class="comment">//创建线程的控制标志，一般为0，代表创建后立马运行</span></span><br><span class="line"></span><br><span class="line">[out] lpThreadId <span class="comment">//返回创建线程的句柄</span></span><br></pre></td></tr></table></figure>
<p>所以传入线程运行的函数地址就是LoadLibrary的地址，这个函数由kernel32.dll中导出，运行函数的参数就是写入目标进程中的DLL的绝对地址</p>
<p>总结一下远线程注入分以下几步</p>
<ol>
<li>打开目标进程</li>
<li>在目标进程开辟一段内存空间，写入要注入的DLL的路径</li>
<li>获取kernel32.dll的模块句柄，然后获取LoadLibrary导出函数的句柄</li>
<li>给目标创建一个线程，线程函数为LoadLibrary，参数为DLL路径</li>
<li>线程运行后会加载指定的DLL</li>
</ol>
<p>测试用例为notapad.exe，向其注入DLL，测试环境为本机Win10</p>
<p><strong>注：CreatRemoteThread方法在Windows 2000/XP/XP SP1 上都可以正常工作，但是从Windows Vista开始，由于微软为了增强系统安全性，引入了会话（Session）隔离的机制，所以就无法再使用CreatRemoteThread向系统服务中注入DLL，只能向同一个Session会话中的进程注入</strong></p>
<p>这里由于notepad.exe是属于用户层的，所以向其使用CreatRemoteThread注入还是可行的，但是就无法注入系统进程了</p>
<p>直接上代码，注入的dllmain.cpp源码（记得选择x64编译，由于notepad.exe为64位应用），编译完后我这里放在本地D盘根目录下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;DLL Inject!!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>远线程注入源码，新建一个空项目即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据进程名获取PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">getpidbyname</span><span class="params">(<span class="type">const</span> WCHAR* ProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE Processes = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 ProcessInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(Processes, &amp;ProcessInfo) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmpW</span>(ProcessInfo.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ProcessInfo.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ProcessInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(ProcessInfo));</span><br><span class="line">        ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(Processes, &amp;ProcessInfo));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* func)</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func loaddll = <span class="literal">NULL</span>;<span class="comment">//指向LoadLibrary的函数指针</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//notepad进程句柄</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>; <span class="comment">//创建的线程句柄</span></span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>; <span class="comment">//kernel32.dll模块句柄</span></span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>; <span class="comment">//存放DLL路径的指针</span></span><br><span class="line"></span><br><span class="line">    LPCTSTR DllPath = <span class="string">L&quot;D:\\dll_test.dll&quot;</span>; <span class="comment">//DLL路径字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定路径需要占用的缓冲区大小,_tcslen测量字符串的长度,然后加上结尾的空字符,再乘sizeof(TCHAR)</span></span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(DllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    DWORD id = <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, id)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用VirtualAllocEx函数在目标进程中分配内存，大小为Dll路径的大小</span></span><br><span class="line">    <span class="comment">//VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存的首地址</span></span><br><span class="line">    pRemoteBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">    <span class="keyword">if</span> (pRemoteBuf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dll路径写入目标进程中分配到的内存</span></span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuf, (LPVOID)DllPath, dwBufSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadLibrary() API的地址</span></span><br><span class="line">    <span class="comment">// 这里主要利用来了kernel32.dll文件在每个进程中的加载地址都相同这一特点，所以不管是获取加载到       </span></span><br><span class="line">    <span class="comment">// InjectDll.exe还是notepad.exe进程的kernel32.dll中的LoadLibraryW函数的地址都是一样的。这里的加载地</span></span><br><span class="line">    <span class="comment">// 址相同指的是在同一次系统运行中，如果再次启动系统kernel32.dll的加载地址会变，但是每个进程的</span></span><br><span class="line">    <span class="comment">// kernerl32.dll的加载地址还是一样的。</span></span><br><span class="line">    hMod = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>); <span class="comment">//直接获取kernel32.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取kernel32.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaddll =(func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);<span class="comment">//为之前定义的函数指针赋成kernel32.dll中LoadLibraryW函数的地址</span></span><br><span class="line">    <span class="keyword">if</span> (loaddll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibrary地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标进程notepad.exe中运行远程线程</span></span><br><span class="line">    <span class="comment">// loaddll 是notepad.exe进程内存中的LoadLibrary()地址</span></span><br><span class="line">    <span class="comment">// pRemoteBuf 是notepad.exe进程内存中待加载注入dll的路径字符串的地址</span></span><br><span class="line">    <span class="keyword">if</span> (!(hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)loaddll, pRemoteBuf, <span class="number">0</span>, <span class="literal">NULL</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建远线程失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先开启记事本，然后运行注入程序，成功注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712134051853.png" alt="image-20220712134051853"></p>
<p>使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer">ProcessExplorer</a>可以看到notepad.exe成功加载我们的dll</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712140602771.png" alt="image-20220712140602771"></p>
<h2 id="RtlCreateUserThread法"><a class="header-anchor" href="#RtlCreateUserThread法">¶</a>RtlCreateUserThread法</h2>
<p>这是一个未公开的WindowsAPI，在ntdll.dll中导出，实际上是CreatRemoteThread方法的底层实现，它比CreatRemoteThread强大的地方在于可以跨Session创建线程，这也就解决了前面CreatRemoteThread无法注入系统进程的弊端，那么实际上RtlCreateUserThread的使用和CreatRemoteThread大同小异，只是多了一个获取RtlCreateUserThread函数地址的步骤，RtlCreateUserThread函数定义及参数如下，用法也比较简单，只需传入几个关键参数即可，其他传入NULL或0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">RtlCreateUserThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN HANDLE                     ProcessHandle,  <span class="comment">//指定开启远线程的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN PSECURITY_DESCRIPTOR     SecurityDescriptor, <span class="comment">//置NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN BOOL                     CreateSuspended,<span class="comment">//置0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG                    StackZeroBits, <span class="comment">//置0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT PULONG                StackReserved, <span class="comment">//置0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT PULONG                StackCommit, <span class="comment">//置0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPVOID                    StartAddress, <span class="comment">//线程执行的函数起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPVOID                    StartParameter, <span class="comment">//线程执行函数的参数起始地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT HANDLE                     ThreadHandle, <span class="comment">//返回创建线程的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">    OUT LPVOID                    ClientID <span class="comment">//置0</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure>
<p>此时由于RtlCreateUserThread可以给系统进程创建线程了，那么如果需要打开一个系统进程，普通的权限是不可以的，所以就需要给当前程序进行提权，提权后就能够打开系统进程了，提权相关API定义如下</p>
<p><strong>OpenProcessToken</strong></p>
<p>打开与进程关联的访问令牌</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in HANDLE ProcessHandle, <span class="comment">//要修改访问权限的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD DesiredAccess, <span class="comment">//指定你要进行的操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">__out PHANDLE TokenHandle <span class="comment">//返回的访问令牌指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>LookupPrivilegeValueA</strong></p>
<p>检索指定系统上使用的本地唯一标识符 (LUID)，以在本地表示指定的特权名称</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LookupPrivilegeValueA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpSystemName, <span class="comment">//要查看的系统，本地系统直接用NULL</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpName,    <span class="comment">//指向一个以零结尾的字符串，指定特权的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function">  PLUID  lpLuid     <span class="comment">//用来接收所返回的制定特权名称的信息</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>AdjustTokenPrivileges</strong></p>
<p>启用或禁用指定访问令牌中的权限。在访问令牌中启用或禁用权限需要 TOKEN_ADJUST_PRIVILEGES 访问权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">AdjustTokenPrivileges</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE TokenHandle, <span class="comment">//包含特权的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">BOOL DisableAllPrivileges,<span class="comment">//禁用所有权限标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">PTOKEN_PRIVILEGES NewState,<span class="comment">//新特权信息的指针(结构体)</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD BufferLength, <span class="comment">//缓冲数据大小,以字节为单位的PreviousState的缓存区(sizeof)</span></span></span></span><br><span class="line"><span class="params"><span class="function">PTOKEN_PRIVILEGES PreviousState,<span class="comment">//接收被改变特权当前状态的Buffer</span></span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD ReturnLength <span class="comment">//接收PreviousState缓存区要求的大小</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一个通用的提权函数，获取指定权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDebugPrivilege</span><span class="params">(LPCWSTR lPcstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Token = <span class="literal">NULL</span>;</span><br><span class="line">    LUID luid = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TOKEN_PRIVILEGES Token_privileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//内存初始化为zero</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;luid, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(luid));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Token_privileges, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(Token_privileges));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开进程令牌</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;Token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取特权luid</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, lPcstr, &amp;luid))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定结构体luid与特权</span></span><br><span class="line">    Token_privileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改进程特权</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(Token, FALSE, &amp;Token_privileges, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入步骤如下所示</p>
<ol>
<li>给当前程序提权</li>
<li>打开目标进程</li>
<li>在目标进程开辟一段内存空间，写入要注入的DLL的路径</li>
<li>获取ntdll.dll的模块句柄，从中获取RtlCreateUserThread函数地址</li>
<li>获取kernel32.dll的模块句柄，然后获取LoadLibrary导出函数的句柄</li>
<li>调用RtlCreateUserThread创建远程线程，线程函数为LoadLibrary，参数为DLL路径</li>
<li>线程运行后会加载指定的DLL</li>
</ol>
<p>测试用例还是notepad.exe，向其注入DLL，测试环境为本机Win10</p>
<p>注入dllmain.cpp的源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;DLL Inject!!&quot;</span>), <span class="built_in">TEXT</span>(<span class="string">&quot;In a DLL&quot;</span>), MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入程序源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提权函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDebugPrivilege</span><span class="params">(LPCWSTR lPcstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Token = <span class="literal">NULL</span>;</span><br><span class="line">    LUID luid = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TOKEN_PRIVILEGES Token_privileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//内存初始化为zero</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;luid, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(luid));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Token_privileges, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(Token_privileges));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开进程令牌</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;Token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取特权luid</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, lPcstr, &amp;luid))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定结构体luid与特权</span></span><br><span class="line">    Token_privileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改进程特权</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(Token, FALSE, &amp;Token_privileges, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过进程名获取进程PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">getpidbyname</span><span class="params">(<span class="type">const</span> WCHAR* ProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE Processes = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 ProcessInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(Processes, &amp;ProcessInfo) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmpW</span>(ProcessInfo.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ProcessInfo.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ProcessInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(ProcessInfo));</span><br><span class="line">        ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(Processes, &amp;ProcessInfo));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* func)</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建RtlCreateUserThread函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pRtlCreateUserThread)</span><span class="params">(    </span></span></span><br><span class="line"><span class="params"><span class="function">    IN HANDLE                     ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN PSECURITY_DESCRIPTOR     SecurityDescriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN BOOL                     CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN ULONG                    StackZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT PULONG                StackReserved,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN OUT PULONG                StackCommit,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPVOID                    StartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN LPVOID                    StartParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT HANDLE                     ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    OUT LPVOID                    ClientID</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func loaddll = <span class="literal">NULL</span>;<span class="comment">//指向LoadLibrary的函数指针</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//notepad进程句柄</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>; <span class="comment">//创建的线程句柄</span></span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>; <span class="comment">//kernel32.dll模块句柄</span></span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>; <span class="comment">//存放DLL路径的指针</span></span><br><span class="line"></span><br><span class="line">    LPCTSTR DllPath = <span class="string">L&quot;D:\\dll_test.dll&quot;</span>; <span class="comment">//DLL路径字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定路径需要占用的缓冲区大小,_tcslen测量字符串的长度,然后加上结尾的空字符,再乘sizeof(TCHAR)</span></span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(DllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据进程名获取PID</span></span><br><span class="line">    DWORD id = <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本进程提权</span></span><br><span class="line">    <span class="comment">//提升进程特权，获得调试权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDebugPrivilege</span>(SE_DEBUG_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程提权失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, id)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用VirtualAllocEx函数在目标进程中分配内存，大小为Dll路径的大小</span></span><br><span class="line">    <span class="comment">//VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存的首地址</span></span><br><span class="line">    pRemoteBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">    <span class="keyword">if</span> (pRemoteBuf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dll路径写入目标进程中分配到的内存</span></span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuf, (LPVOID)DllPath, dwBufSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadLibraryW的地址</span></span><br><span class="line">    hMod = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>); <span class="comment">//直接获取kernel32.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取kernel32.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaddll =(func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);<span class="comment">//为之前定义的函数指针赋成kernel32.dll中LoadLibrary函数的地址</span></span><br><span class="line">    <span class="keyword">if</span> (loaddll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibrary地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取RtlCreateUserThread的地址</span></span><br><span class="line">    HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>);<span class="comment">//获取ntdll.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (ntdll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取ntdll.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取RtlCreateUserThread函数的地址</span></span><br><span class="line">    pRtlCreateUserThread rtl = (pRtlCreateUserThread)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">&quot;RtlCreateUserThread&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取RtlCreateUserThread地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE threadhandle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 在目标进程notepad.exe中运行远程线程 使用RtlCreateUserThread方法</span></span><br><span class="line">    <span class="built_in">rtl</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)loaddll, pRemoteBuf, &amp;threadhandle, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (threadhandle==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建远线程失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打开记事本后，运行注入程序，成功注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712170439067.png" alt="image-20220712170439067"></p>
<p>使用ProcessExplorer查看，成功注入我们的DLL</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712170522308.png" alt="image-20220712170522308"></p>
<h2 id="NtCreateThreadEx-ZwCreateThreadEx法"><a class="header-anchor" href="#NtCreateThreadEx-ZwCreateThreadEx法">¶</a>NtCreateThreadEx/ZwCreateThreadEx法</h2>
<p>相比于CreatRemoteThread和RtlCreateUserThread，NtCreateThreadEx/ZwCreateThreadEx是两个更加底层的未公开的API，同样是从ntdll.dll中导出，可以理解为前两种都是后两者的一种封装，那么这两个函数的使用和RtlCreateUserThread非常相似，只需要获取对应地址即可，传入关键参数即可完成创建远线程</p>
<p>那么NtCreateThreadEx/ZwCreateThreadEx他两又有什么区别呢，看到<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42021840/article/details/105782508">一篇文章</a>解析了Nt*和Zw*函数</p>
<p>那么就可以理解为在ring3层这两个函数是没有区别的，只是在ring0层这两个函数稍有区别在于Nt*会直接调用调用函数代码，而使用Zw*会进行一次跳转</p>
<p>我们的调用在用户态在ring3层所以说实际上是没有区别的，通过函数定义就可以看出来</p>
<p>对于NtCreateThreadEx的函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* PfnZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T MaximunStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI *PfnZwCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    BOOL CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于ZwCreateThreadEx的函数定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">         PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">         ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">         HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">         ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">         SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">         SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">         SIZE_T MaximumStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID pUnkown)</span></span>;</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ZwCreateThreadEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">         PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">         ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">         HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">         BOOL CreateSuspended,</span></span></span><br><span class="line"><span class="params"><span class="function">         DWORD dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">         DWORD dw1,</span></span></span><br><span class="line"><span class="params"><span class="function">         DWORD dw2,</span></span></span><br><span class="line"><span class="params"><span class="function">         LPVOID pUnkown)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里简单解释以下64位操作系统时如果使用此方法进行创建远线程时传入的参数意义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PHANDLE ThreadHandle,  <span class="comment">//返回创建线程的句柄</span></span><br><span class="line">ACCESS_MASK DesiredAccess,  <span class="comment">//线程权限，一般为THREAD_ALL_ACCESS</span></span><br><span class="line">LPVOID ObjectAttributes, <span class="comment">//置NULL</span></span><br><span class="line">HANDLE ProcessHandle, <span class="comment">//想要创建线程的进程句柄</span></span><br><span class="line">LPTHREAD_START_ROUTINE lpStartAddress, <span class="comment">//进程执行的函数地址</span></span><br><span class="line">LPVOID lpParameter, <span class="comment">//执行函数的参数</span></span><br><span class="line">ULONG CreateThreadFlags, <span class="comment">//置NULL（关键点）</span></span><br><span class="line">SIZE_T ZeroBits, <span class="comment">//置0</span></span><br><span class="line">SIZE_T StackSize, <span class="comment">//置0</span></span><br><span class="line">SIZE_T MaximunStackSize, <span class="comment">//置0</span></span><br><span class="line">LPVOID pUnkown <span class="comment">//置0</span></span><br></pre></td></tr></table></figure>
<p>CreatRemoteThread方法最终会调用到ZwCreateThreadEx，使用其来创建远线程，但是Windows Vista以上引入的session机制，它在创建一个进程之后并不立即运行，而是先挂起进程，在查看要运行的进程所在的会话层之后再决定是否恢复进程运行，根据<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269910.htm#msg_header_h1_3">这篇文章</a>的解释</p>
<p>在内核6.0(WIN7, WIN10)等系统上调用CreateRemoteThread的时候，当程序走到ZwCreateThreaEx的时候它第7个参数，也就是CreateThreadFlags会被设置为1，它会导致线程创建时就被挂机</p>
<p>所以我们主动调用NtCreateThreadEx/ZwCreateThreadEx函数时，创建线程的关键点就在于将第七个参数<code>ULONG CreateThreadFlags</code>置为NULL(0)</p>
<p>注入流程和RtlCreateUserThread一样，直接上代码，这里使用NtCreateThreadEx，如果使用ZwCreateThreadEx，只需在GetProcAddress时传入ZwCreateThreadEx即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程提权</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDebugPrivilege</span><span class="params">(LPCWSTR lPcstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE Token = <span class="literal">NULL</span>;</span><br><span class="line">    LUID luid = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    TOKEN_PRIVILEGES Token_privileges = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">//内存初始化为zero</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;luid, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(luid));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;Token_privileges, <span class="number">0x00</span>, <span class="built_in">sizeof</span>(Token_privileges));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开进程令牌</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, &amp;Token))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取特权luid</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>, lPcstr, &amp;luid))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定结构体luid与特权</span></span><br><span class="line">    Token_privileges.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    Token_privileges.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改进程特权</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">AdjustTokenPrivileges</span>(Token, FALSE, &amp;Token_privileges, <span class="built_in">sizeof</span>(TOKEN_PRIVILEGES), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过进程名获取PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">getpidbyname</span><span class="params">(<span class="type">const</span> WCHAR* ProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE Processes = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 ProcessInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(Processes, &amp;ProcessInfo) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmpW</span>(ProcessInfo.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ProcessInfo.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ProcessInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(ProcessInfo));</span><br><span class="line">        ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(Processes, &amp;ProcessInfo));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* func)</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明NtCreateThreadEx函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* NtCreateThreadEx)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PHANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID ObjectAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">    ULONG CreateThreadFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T ZeroBits,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T StackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T MaximunStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID pUnkown)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func loaddll = <span class="literal">NULL</span>;<span class="comment">//指向LoadLibrary的函数指针</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//notepad进程句柄</span></span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>; <span class="comment">//创建的线程句柄</span></span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>; <span class="comment">//kernel32.dll模块句柄</span></span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>; <span class="comment">//存放DLL路径的指针</span></span><br><span class="line"></span><br><span class="line">    LPCTSTR DllPath = <span class="string">L&quot;D:\\dll_test.dll&quot;</span>; <span class="comment">//DLL路径字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定路径需要占用的缓冲区大小,_tcslen测量字符串的长度,然后加上结尾的空字符,再乘sizeof(TCHAR)</span></span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(DllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据进程名获取PID</span></span><br><span class="line">    DWORD id = <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//本进程提权</span></span><br><span class="line">    <span class="comment">//提升进程特权，获得调试权限</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">GetDebugPrivilege</span>(SE_DEBUG_NAME))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;进程提权失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, id)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用VirtualAllocEx函数在目标进程中分配内存，大小为Dll路径的大小</span></span><br><span class="line">    <span class="comment">//VirtualAllocEx函数返回的是hProcess指向的目标进程的分配所得缓冲区的内存的首地址</span></span><br><span class="line">    pRemoteBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">    <span class="keyword">if</span> (pRemoteBuf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将dll路径写入目标进程中分配到的内存</span></span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuf, (LPVOID)DllPath, dwBufSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadLibraryW的地址</span></span><br><span class="line">    hMod = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>); <span class="comment">//直接获取kernel32.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取kernel32.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaddll =(func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);<span class="comment">//为之前定义的函数指针赋成kernel32.dll中LoadLibrary函数的地址</span></span><br><span class="line">    <span class="keyword">if</span> (loaddll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibrary地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取NtCreateThreadEx的地址</span></span><br><span class="line">    HMODULE ntdll = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>);<span class="comment">//获取ntdll.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (ntdll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取ntdll.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NtCreateThreadEx rtl = (NtCreateThreadEx)<span class="built_in">GetProcAddress</span>(ntdll, <span class="string">&quot;NtCreateThreadEx&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtl == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取NtCreateThreadEx地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HANDLE threadhandle = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 在目标进程notepad.exe中运行远程线程 使用NtCreateThreadEx方法</span></span><br><span class="line">    <span class="built_in">rtl</span>(&amp;threadhandle, THREAD_ALL_ACCESS, <span class="literal">NULL</span>, hProcess, (LPTHREAD_START_ROUTINE)loaddll, pRemoteBuf, <span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (threadhandle==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建远线程失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注入的DLL和上文一样，注入对象为notepad.exe，运行注入程序，成功注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712174315872.png" alt="image-20220712174315872"></p>
<p>查看notepad.exe成功注入DLL</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712174839650.png" alt="image-20220712174839650"></p>
<h2 id="APC注入法"><a class="header-anchor" href="#APC注入法">¶</a>APC注入法</h2>
<p>APC是Asynchronous Procedure Call（异步调用过程）的缩写。它是一种软中断机制，当一个线程从等待状态苏醒时，他会检测有没有APC交给自己。如果有，就会执行这些APC过程。我们可以使用QueueUserAPC函数将一个APC交给某个进程的某个线程，就可以利用这种机制使得线程执行加载DLL的操作，造成DLL注入，简单概括为以下几步</p>
<ol>
<li>当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）</li>
<li>当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数</li>
<li>利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的</li>
</ol>
<p>为了能够使得DLL注入尽快被执行，一般都会将APC过程添加到一个进程的所有线程当中，所以就需要遍历线程，然后依次使用QueueUserAPC将一个APC过程添加到目标线程的队列当中</p>
<p>但是APC注入比较有局限性，主要原因如下</p>
<ul>
<li>注入程序必须是多线程</li>
<li>注入程序必须调用中断方法，使得线程从挂起到执行</li>
</ul>
<p>QueueUserAPC官方定义：</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712180939021.png" alt="image-20220712180939021"></p>
<p>每个参数定义为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[in] pfnAPC  <span class="comment">//APC执行函数的地址</span></span><br><span class="line"></span><br><span class="line">[in] hThread  <span class="comment">//线程句柄</span></span><br><span class="line"></span><br><span class="line">[in] dwData  <span class="comment">//APC函数的参数</span></span><br></pre></td></tr></table></figure>
<p>注入原理就是对每个线程执行QueueUserAPC方法，传入参数pfnAPC为LoadLibrary函数地址，dwData就为加载DLL的路径</p>
<p>那么APC注入的大致流程为</p>
<ol>
<li>打开目标进程</li>
<li>在目标进程开辟一段内存空间，写入要注入的DLL的路径</li>
<li>获取kernel32.dll的模块句柄，然后获取LoadLibrary导出函数的句柄</li>
<li>遍历目标进程的线程，给每个线程注入APC过程</li>
<li>线程唤醒后会执行APC过程从而造成DLL加载</li>
</ol>
<p>可以看到流程的前三步和前面的远线程注入准备操作是一样的</p>
<p>被注入的DLL和上文一样，给出APC注入程序代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">getpidbyname</span><span class="params">(<span class="type">const</span> WCHAR* ProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE Processes = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 ProcessInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(Processes, &amp;ProcessInfo) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmpW</span>(ProcessInfo.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ProcessInfo.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ProcessInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(ProcessInfo));</span><br><span class="line">        ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(Processes, &amp;ProcessInfo));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* func)</span><span class="params">(LPCWSTR lpLibFileName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func loaddll = <span class="literal">NULL</span>;<span class="comment">//指向LoadLibrary的函数指针</span></span><br><span class="line">    HANDLE hProcess = <span class="literal">NULL</span>; <span class="comment">//notepad进程句柄</span></span><br><span class="line">    HMODULE hMod = <span class="literal">NULL</span>; <span class="comment">//kernel32.dll模块句柄</span></span><br><span class="line">    LPVOID pRemoteBuf = <span class="literal">NULL</span>; <span class="comment">//存放DLL路径的指针</span></span><br><span class="line"></span><br><span class="line">    LPCTSTR DllPath = <span class="string">L&quot;D:\\dll_test.dll&quot;</span>; <span class="comment">//DLL路径字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//确定路径需要占用的缓冲区大小,_tcslen测量字符串的长度,然后加上结尾的空字符,再乘sizeof(TCHAR)</span></span><br><span class="line">    DWORD dwBufSize = (DWORD)(_tcslen(DllPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(TCHAR);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据进程名获取PID</span></span><br><span class="line">    DWORD id = <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OpenProcess函数获取目标进程句柄（PROCESS_ALL_ACCESS权限）</span></span><br><span class="line">    <span class="keyword">if</span> (!(hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, id)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开进程失败\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用VirtualAllocEx函数在目标进程中分配内存，大小为Dll路径的大小</span></span><br><span class="line">    pRemoteBuf = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, dwBufSize, MEM_COMMIT, PAGE_READWRITE); </span><br><span class="line">    <span class="keyword">if</span> (pRemoteBuf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;申请内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将路径写入目标进程中分配到的内存</span></span><br><span class="line">    <span class="keyword">if</span> (FALSE == <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteBuf, (LPVOID)DllPath, dwBufSize, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取LoadLibraryW的地址</span></span><br><span class="line">    hMod = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>); <span class="comment">//直接获取kernel32.dll的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (hMod == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取kernel32.dll地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    loaddll =(func)<span class="built_in">GetProcAddress</span>(hMod, <span class="string">&quot;LoadLibraryW&quot;</span>);<span class="comment">//为之前定义的函数指针赋成kernel32.dll中LoadLibrary函数的地址</span></span><br><span class="line">    <span class="keyword">if</span> (loaddll == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;获取LoadLibrary地址失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历notepad的线程</span></span><br><span class="line">    THREADENTRY32 th32 ;</span><br><span class="line">    th32.dwSize = <span class="built_in">sizeof</span>(THREADENTRY32);</span><br><span class="line">    HANDLE hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开线程快照失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(hThreadSnap, &amp;th32))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (th32.th32OwnerProcessID == id)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果是目标程序的线程，则获得线程句柄，然后注入APC过程</span></span><br><span class="line">                HANDLE hThread = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, th32.th32ThreadID);</span><br><span class="line">                <span class="keyword">if</span> (hThread)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//注入APC过程</span></span><br><span class="line">                    DWORD dwret = <span class="built_in">QueueUserAPC</span>((PAPCFUNC)loaddll, hThread, (ULONG_PTR)pRemoteBuf);</span><br><span class="line">                    <span class="keyword">if</span> (dwret == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;APC inject\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(hThreadSnap,&amp;th32));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThreadSnap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，看到成功注入了12个线程</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185702496.png" alt="image-20220712185702496"></p>
<p>然后稍作等待，这里我测试的时候等了三四秒，然后成功注入DLL，主要是触发条件需要线程被唤醒，所以DLL并不会立马被注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185808715.png" alt="image-20220712185808715"></p>
<p>查看notepad加载的DLL</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712185838341.png" alt="image-20220712185838341"></p>
<h1>0x06 利用系统机制加载DLL</h1>
<p>操作系统提供的某些机制是依赖一些基础服务模块实现的，当进程主动或者被动触发了这些系统机制时，就会在适当的时候主动加载这些模块。因此可以定制一个符合该规范的DLL，将其注册为系统服务模块，这样就可以“合法”的进入目标进程了</p>
<h2 id="SetWindowHookEx消息钩子注入"><a class="header-anchor" href="#SetWindowHookEx消息钩子注入">¶</a>SetWindowHookEx消息钩子注入</h2>
<p>消息钩子时Window提供的一种消息过滤和预处理机制，可以通过SetWindowHookEx安装，可以理解为官方支持的一种HOOK消息的手段，函数定义如下</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712194354808.png" alt="image-20220712194354808"></p>
<p>具体说一下每个参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[in] idHook <span class="comment">//指定了要安装的HOOK的类型，可以是以下的几种</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">WH_MSGFILTER</span>(<span class="number">-1</span>):安装一个挂钩过程来监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息</span><br><span class="line"><span class="built_in">WH_JOURNALRECORD</span>(<span class="number">0</span>)：安装一个挂钩过程，记录发布到系统消息队列的输入消息</span><br><span class="line"><span class="built_in">WH_JOURNALPLAYBACK</span>(<span class="number">1</span>):安装一个挂钩过程，该过程发布以前由 WH_JOURNALRECORD 挂钩过程记录的消息</span><br><span class="line"><span class="built_in">WH_KEYBOARD</span>(<span class="number">2</span>):安装一个挂钩程序来监视击键消息</span><br><span class="line"><span class="built_in">WH_GETMESSAGE</span>(<span class="number">3</span>):安装一个挂钩过程来监视发布到消息队列的消息</span><br><span class="line"><span class="built_in">WH_CALLWNDPROC</span>(<span class="number">4</span>):在系统将消息发送到目标窗口过程之前，安装一个挂钩过程来监视消息</span><br><span class="line"><span class="built_in">WH_CBT</span>(<span class="number">5</span>):安装一个钩子程序来接收对 CBT 应用程序有用的通知</span><br><span class="line"><span class="built_in">WH_SYSMSGFILTER</span>(<span class="number">6</span>):安装一个挂钩过程来监视由于对话框、消息框、菜单或滚动条中的输入事件而生成的消息</span><br><span class="line"><span class="built_in">WH_MOUSE</span>(<span class="number">7</span>):安装一个监视鼠标消息的挂钩过程</span><br><span class="line"><span class="built_in">WH_DEBUG</span>(<span class="number">9</span>):安装一个对调试其他钩子程序有用的钩子程序</span><br><span class="line"><span class="built_in">WH_SHELL</span>(<span class="number">10</span>):安装一个挂钩程序，用于接收对 shell 应用程序有用的通知</span><br><span class="line"><span class="built_in">WH_FOREGROUNDIDLE</span>(<span class="number">11</span>):安装将在应用程序的前台线程即将空闲时调用的钩子过程。这个钩子对于在空闲时间执行低优先级任务很有用</span><br><span class="line"><span class="built_in">WH_CALLWNDPROCRET</span>(<span class="number">12</span>):安装一个钩子过程，在消息被目标窗口过程处理后监视它们</span><br><span class="line"><span class="built_in">WH_KEYBOARD_LL</span>(<span class="number">13</span>):安装一个监视低级键盘输入事件的挂钩过程</span><br><span class="line"><span class="built_in">WH_MOUSE_LL</span>(<span class="number">14</span>):安装一个监视低级鼠标输入事件的钩子过程</span><br><span class="line"></span><br><span class="line">[in] lpfn <span class="comment">//Hook过程的回调函数</span></span><br><span class="line"></span><br><span class="line">[in] hmod <span class="comment">//Hook过程的DLL</span></span><br><span class="line"></span><br><span class="line">[in] dwThreadId <span class="comment">//指定被Hook的线程id，如果为0，则代表给所有线程装载hook</span></span><br></pre></td></tr></table></figure>
<p>所以利用SetWindowHookEx进行DLL注入主要利用点就是在于最后一个指定线程ID的参数，如果参数为0，就代表安装一个全局的消息钩子，就会进行全局Hook，那么同时需要满足两个条件</p>
<ul>
<li>第二个参数所指向的hook回调函数必须定义在一个DLL中（以便于其他线程加载）</li>
<li>第三个参数所指向的DLL必须被指定而不能为NULL（全局钩子会将这个DLL注入到全部线程当中，然后调用其中的回调函数）</li>
</ul>
<p>所以这样加载一个全局钩子时，其他进程调用hook回调函数时就会发现DLL未加载，此时会将DLL加载进自己进程中，这样就完成了一次DLL注入</p>
<p>所以要做的就是编写一个DLL作为全局消息钩子DLL，并且在其中定义回调函数，并且可以导出一个加载全局钩子的函数，只要我们再写一个程序加载DLL后调用导出函数，即可完成全局钩子的挂载</p>
<p>由于是全局注入，所以进程都会加载DLL，为了不影响其他程序，在DLLMain中加上判断，只有notepad才会弹窗，其他程序则没有影响</p>
<p>这里安装的全局钩子的Hook类型选择WH_GETMESSAGE，监视发布到消息队列的消息，触发次数较多，对应WH_GETMESSAGE类型的回调函数也比较简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MsgHookProc</span><span class="params">(<span class="type">int</span> code,WPARAM wparam,LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(ghook, code, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只是简单的调用CallNextHookEx函数表示将当前钩子传递给钩链中的下一个钩子，第一个参数要指定当前钩子的句柄。如果直接返回0，则表示中断钩子传递，这就实现了对钩子进行拦截</p>
<p>当不使用钩子的时候，就需要将其卸载，使用UnhookWindowsHookEx方法进行卸载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UnhookWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in] HHOOK hhk <span class="comment">//要移除钩子的句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的全局钩子的设置，钩子回调函数的实现以及全局钩子的卸载都需要使用到全局钩子的句柄。为了让任意一个独立的进程中对句柄的修改都可以影响到其他进程，就需要在DLL中使用共享内存的，来保证将DLL中加载到多个进程以后，一个进程对它的修改可以影响到其他进程，设置共享内存的方式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;data&quot;</span>)</span></span><br><span class="line">HHOOK ghHook = <span class="literal">NULL</span>; <span class="comment">//全局共享的钩子句柄</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:data,RWS&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<p>并且由于SetWindowHookEx创建全局钩子时第三个参数hmod为DLL句柄，而这个DLL正是我们定义的DLL本身，所以需要在DLL中设置一个全部变量保存句柄，而之前我们学到DLLMain函数的hinstDLL参数指向的就是自身的句柄，所以在DLLMain中将句柄赋值给全局变量即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HMODULE gmodule = <span class="literal">NULL</span>; <span class="comment">//全局变量保存DLL句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//DLL首次加载时</span></span><br><span class="line">        gmodule = hModule;<span class="comment">//将hModule赋值给gmodule即获得自身句柄</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetCurrentProcessId</span>() == <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;install dll&quot;</span>, <span class="string">&quot;In a DLL&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局钩子dllmain.cpp代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg(<span class="string">&quot;data&quot;</span>)</span></span><br><span class="line">HHOOK ghook = <span class="literal">NULL</span>; <span class="comment">//全局共享的钩子句柄</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/SECTION:data,RWS&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据进程名获取PID</span></span><br><span class="line"><span class="function">DWORD <span class="title">getpidbyname</span><span class="params">(<span class="type">const</span> WCHAR* ProcessName)</span> </span>&#123;</span><br><span class="line">    HANDLE Processes = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line">    PROCESSENTRY32 ProcessInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(Processes, &amp;ProcessInfo) == <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">lstrcmpW</span>(ProcessInfo.szExeFile, ProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ProcessInfo.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ProcessInfo, <span class="number">0</span>, <span class="built_in">sizeof</span>(ProcessInfo));</span><br><span class="line">        ProcessInfo.dwSize = <span class="built_in">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(Processes, &amp;ProcessInfo));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE gmodule = <span class="literal">NULL</span>; <span class="comment">////全局变量保存自身DLL句柄</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:<span class="comment">//DLL首次加载时</span></span><br><span class="line">        gmodule = hModule;<span class="comment">//将hModule赋值给gmodule即获得自身句柄</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetCurrentProcessId</span>() == <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;install dll&quot;</span>, <span class="string">&quot;In a DLL&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:<span class="comment">//DLL被卸载时</span></span><br><span class="line">        gmodule = hModule;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetCurrentProcessId</span>() == <span class="built_in">getpidbyname</span>(<span class="string">L&quot;notepad.exe&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;uninstall dll&quot;</span>, <span class="string">&quot;In a DLL&quot;</span>, MB_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SetWindowsHookEx的回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">MsgHookProc</span><span class="params">(<span class="type">int</span> code, WPARAM wparam, LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CallNextHookEx</span>(ghook, code, wparam, lparam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出函数，用来设置全局钩子</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">installhook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ghook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, MsgHookProc, gmodule, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出函数，用来卸载全局钩子</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">uninstallhook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">UnhookWindowsHookEx</span>(ghook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个简单的加载程序，来加载DLL，并用来设置全局钩子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*installhook)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*uninstallhook)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HMODULE hmod  = <span class="built_in">LoadLibrary</span>(<span class="string">L&quot;dll_test.dll&quot;</span>);</span><br><span class="line">	installhook install = (installhook)<span class="built_in">GetProcAddress</span>(hmod, <span class="string">&quot;installhook&quot;</span>);</span><br><span class="line">	uninstallhook uninstall = (uninstallhook)<span class="built_in">GetProcAddress</span>(hmod, <span class="string">&quot;uninstallhook&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;安装全局钩子\n&quot;</span>);</span><br><span class="line">	<span class="built_in">install</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入q卸载全局钩子\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">getchar</span>() == <span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">uninstall</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意要将DLL和我们的加载程序放在同一个目录下</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222041955.png" alt="image-20220712222041955"></p>
<p>然后运行加载程序</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222130082.png" alt="image-20220712222130082"></p>
<p>显示安装成功，然后打开记事本</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222156115.png" alt="image-20220712222156115"></p>
<p>成功安装全局钩子，然后输入q来卸载全局钩子</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220712222243845.png" alt="image-20220712222243845"></p>
<h2 id="AppInit-DLLs注册表项注入"><a class="header-anchor" href="#AppInit-DLLs注册表项注入">¶</a>AppInit_DLLs注册表项注入</h2>
<p>之前的注入都是依靠代码来实现注入，而注册表注入是利用了window官方提供的一种机制进行注入，前提条件是程序需要加载user32.dll，即是一个GUI程序</p>
<p>在程序加载user32.dll的时候，会调用一个LoadAppDLLs()函数，他会读取下面这个注册表项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs</span><br></pre></td></tr></table></figure>
<p>如果这个注册表项的键值中登记了DLL，就会主动加载它，在win7中需要的条件是下面这个键值设置成1，在xp中只需要指定上面的注册表项就可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\LoadAppInit_DLLs</span><br></pre></td></tr></table></figure>
<p>这个方法在win7中适用，但是本地测试环境是win10，使用此方法并没有成功加载DLL，搜索了一波发现了<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-US/windows/win32/dlls/secure-boot-and-appinit-dlls">官方文档</a></p>
<p>看到原因是在win8及以上时当以Secure Boot方式启动系统后，AppInit_DLLs加载DLL的机制将会被禁用，所以就无法再使用</p>
<p>然后搜索看到一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43787608/article/details/84439171">解决办法</a>，但由于自己的电脑在关闭secure boot时出现了问题，无法复现，文中思路就是</p>
<ol>
<li>进入BIOS设置设置secure boot为disable</li>
<li>然后命令行中以管理员方式运行 bcdedit /set testsigning on 设置系统的test mode</li>
</ol>
<p>之后就可以正常加载AppInit_DLLs下的DLL了</p>
<p>这里我测试选用了win7的虚拟机，配置AppInit_DLLs和LoadAppInit_DLLs</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713015148362.png" alt="image-20220713015148362"></p>
<p>注入DLL为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        <span class="built_in">MessageBoxA</span>(<span class="literal">NULL</span>, <span class="string">&quot;dll inject!!&quot;</span>, <span class="string">&quot;In a DLL&quot;</span>, MB_OK);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译完后将DLL放在win7虚拟机的指定目录中，并且由于是在win10使用vs2019进行编译的，使用了win10的api，直接编译DLL到win7上加载会报错提示无法找到依赖dll，<strong>必须将运行库设置为多线程(/MT)</strong>，使用静态链接编译一次，这样放到win7上才会成功加载DLL</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713030105998.png" alt="image-20220713030105998"></p>
<p>编译完后将dll放在指定目录，这里我放在桌面上</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135707934.png" alt="image-20220713135707934"></p>
<p>然后打开记事本成功注入DLL</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135038212.png" alt="image-20220713135038212"></p>
<p>打开计算器也成功注入</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713135355943.png" alt="image-20220713135355943"></p>
<p><strong>注：由于是只要加载了user32.dll的程序都会去加载AppInit_DLLs注册表下的DLL，即通常是GUI程序都会加载，所以还是有一定的局限性，如果程序不加载user32.dll就无法使用此方法进行注入</strong></p>
<h1>0x07 总结</h1>
<p>DLL注入由于其技术特点的灵活性，可以在多种领域应用，在软件开发测试，游戏辅助，软件破解，木马病毒，渗透测试等领域都有不错的应用，所以DLL注入作为一种基础技术手段是非常有必要学习的。本文中所注入的DLL都是非常简单的测试demo，但是DLL注入的危害程度是根据所注入的dll来判断的，比如在渗透测试时，如果注入一个cs的恶意dll，就会造成更加严重的后果，这里简单说一下如何使用cs生成一个32位DLL</p>
<p>选中Attacks-&gt;Packages-&gt;Windows Executable</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713165228860.png" alt="image-20220713165228860"></p>
<p>点击Listener右侧按钮，创建一个Listener</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713165403944.png" alt="image-20220713165403944"></p>
<p>然后保存，选择创建的Lister，Output选择32位windows dll</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170055276.png" alt="image-20220713170055276"></p>
<p>点击生成，将DLL保存到本地目录</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170126841.png" alt="image-20220713170126841"></p>
<p>此时成功生成一个32位的DLL，这里测试用例使用游戏Counter-Strike:Source（steam最新版），主进程为hl2.exe是一个32位的进程，所以只能注入32位dll</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170535194.png" alt="image-20220713170535194"></p>
<p>注入方法使用上文中的NtCreateThreadEx远线程注入法，代码没有改动，只是改动了DLL路径名和程序名，运行完后看到cs成功上线</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713170730318.png" alt="image-20220713170730318"></p>
<p>此时用ProcessExplorer查看进程也发现cs恶意dll成功加载</p>
<p><img src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/image-20220713171010833.png" alt="image-20220713171010833"></p>
<p><strong>Reference：</strong></p>
<p>《加密与解密》第四版</p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-268976.htm">https://bbs.pediy.com/thread-268976.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e017b62d8261">https://www.jianshu.com/p/e017b62d8261</a></p>
<p><a target="_blank" rel="noopener" href="http://t.zoukankan.com/jentleTao-p-12728142.html">http://t.zoukankan.com/jentleTao-p-12728142.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43787608/article/details/84439171">https://blog.csdn.net/weixin_43787608/article/details/84439171</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2">https://docs.microsoft.com/en-us/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269910.htm">https://bbs.pediy.com/thread-269910.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42021840/article/details/106154804">https://blog.csdn.net/qq_42021840/article/details/106154804</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/25/XSS&Dom%20Clobbering/" rel="prev" title="XSS&Dom Clobbering">
      <i class="fa fa-chevron-left"></i> XSS&Dom Clobbering
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/28/C2profile%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/" rel="next" title="cobaltstrike_c2profile结构学习">
      cobaltstrike_c2profile结构学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">0x00 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">2.</span> <span class="nav-text">0x01 DLL注入原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">3.</span> <span class="nav-text">0x02 基础WindowsAPI</span></a></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text">0x03 使用VS2019来写一个DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DLLMain%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">DLLMain函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%BC%E5%87%BADLL%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">导出DLL函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E5%8D%95DEMO"><span class="nav-number">4.3.</span> <span class="nav-text">简单DEMO</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">5.</span> <span class="nav-text">0x04 通过干预输入表处理过程加载目标DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E4%BF%AE%E6%94%B9PE%E8%BE%93%E5%85%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">静态修改PE输入表法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%A1%A8%E9%A1%B9DLL%E6%9B%BF%E6%8D%A2%E6%B3%95%EF%BC%88DLL%E5%8A%AB%E6%8C%81%E6%B3%95%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">输入表项DLL替换法（DLL劫持法）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">6.</span> <span class="nav-text">0x05 改变程序运行流程使其主动加载目标DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CreatRemoteThread%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">CreatRemoteThread法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RtlCreateUserThread%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">RtlCreateUserThread法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NtCreateThreadEx-ZwCreateThreadEx%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">NtCreateThreadEx&#x2F;ZwCreateThreadEx法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#APC%E6%B3%A8%E5%85%A5%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">APC注入法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">7.</span> <span class="nav-text">0x06 利用系统机制加载DLL</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SetWindowHookEx%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5"><span class="nav-number">7.1.</span> <span class="nav-text">SetWindowHookEx消息钩子注入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AppInit-DLLs%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9%E6%B3%A8%E5%85%A5"><span class="nav-number">7.2.</span> <span class="nav-text">AppInit_DLLs注册表项注入</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">8.</span> <span class="nav-text">0x07 总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ka1t4v"
      src="https://ka1t4v.oss-cn-zhangjiakou.aliyuncs.com/config/avatar.jpg">
  <p class="site-author-name" itemprop="name">Ka1t4v</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ka1t4v" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ka1t4v" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:ka1t4v@gmail.com" title="E-Mail → mailto:ka1t4v@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ka1t4v</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
